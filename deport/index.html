<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>DEPORT — UFCR Games</title>
  <link rel="icon" href="../assets/images/shield-logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Oswald:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    :root {
      --orange:#FA4616; --gold:#F0A830; --navy:#001845; --dark:#0A0E1A;
      --red:#D32F2F; --green:#43A047;
      --font-body:'Inter',sans-serif; --font-heading:'Oswald',sans-serif;
    }
    *,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%;overflow:hidden;font-family:var(--font-body);background:#1b2b1b;color:#fff;-webkit-tap-highlight-color:transparent;user-select:none}

    .nav{position:fixed;top:0;left:0;right:0;z-index:100;height:48px;background:rgba(0,24,69,0.95);backdrop-filter:blur(20px);border-bottom:1px solid rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:space-between;padding:0 12px}
    .nav-logo{display:flex;align-items:center;gap:6px;text-decoration:none;color:#fff}
    .nav-logo img{height:28px;border-radius:3px;background:#fff;padding:1px}
    .nav-logo span{font-family:var(--font-heading);font-size:1rem;font-weight:700;letter-spacing:.08em}
    .nav-back{font-size:.7rem;color:rgba(255,255,255,.5);text-decoration:none;letter-spacing:.1em;text-transform:uppercase;font-weight:600}

    .hud{position:fixed;top:48px;left:0;right:0;z-index:90;display:flex;justify-content:space-between;padding:8px 16px;background:rgba(0,24,69,.7);backdrop-filter:blur(10px);border-bottom:1px solid rgba(255,255,255,.05)}
    .hud-item{text-align:center;flex:1}
    .hud-label{font-size:.55rem;text-transform:uppercase;letter-spacing:.15em;color:rgba(255,255,255,.35)}
    .hud-value{font-family:var(--font-heading);font-size:1.2rem;font-weight:700}
    .hud-value.score{color:var(--gold)}.hud-value.timer{color:var(--orange)}.hud-value.missed{color:var(--red)}.hud-value.level{color:var(--green)}

    canvas{position:fixed;top:0;left:0;width:100%;height:100%;display:block}

    .screen-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(10,14,26,.93);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:200;padding:24px;text-align:center}
    .screen-overlay.hidden{display:none}
    .screen-title{font-family:var(--font-heading);font-size:clamp(2.5rem,8vw,4.5rem);font-weight:700;text-transform:uppercase;letter-spacing:.04em;margin-bottom:8px}
    .screen-sub{font-size:.95rem;color:rgba(255,255,255,.5);margin-bottom:28px;max-width:380px;line-height:1.6}
    .screen-stats{margin-bottom:28px;min-width:240px}
    .stat-row{display:flex;justify-content:space-between;font-size:.95rem;padding:6px 0;border-bottom:1px solid rgba(255,255,255,.06)}
    .stat-label{color:rgba(255,255,255,.4)}.stat-val{font-weight:700;color:var(--gold)}
    .level-badge{font-family:var(--font-heading);font-size:.7rem;font-weight:600;letter-spacing:.2em;text-transform:uppercase;color:var(--gold);margin-bottom:8px}
    .btn{font-family:var(--font-heading);font-size:1.05rem;font-weight:600;letter-spacing:.12em;text-transform:uppercase;background:var(--orange);color:#fff;border:none;padding:13px 36px;cursor:pointer;transition:all .3s}
    .btn:hover{background:#e03a0e;transform:translateY(-2px)}
    .share-btns{display:flex;gap:10px;margin-top:14px}
    .share-btn{font-family:var(--font-heading);font-size:.7rem;font-weight:600;letter-spacing:.1em;text-transform:uppercase;padding:9px 16px;border:1px solid rgba(255,255,255,.15);background:transparent;color:#fff;cursor:pointer;display:flex;align-items:center;gap:6px;transition:all .3s}
    .share-btn:hover{background:rgba(255,255,255,.08)}
    .instructions{max-width:340px;margin-bottom:24px;text-align:left}
    .instructions li{font-size:.85rem;color:rgba(255,255,255,.55);margin-bottom:6px;line-height:1.5;list-style:none;padding-left:20px;position:relative}
    .instructions li::before{content:'';position:absolute;left:0;top:7px;width:8px;height:8px;border:2px solid var(--orange);border-radius:50%}
  </style>
</head>
<body>

<nav class="nav">
  <a href="../" class="nav-logo"><img src="../assets/images/shield-logo.png" alt="UFCR"><span>UFCR</span></a>
  <a href="../games/" class="nav-back"><i class="fas fa-arrow-left"></i> Games</a>
</nav>

<div class="hud" id="hud" style="display:none">
  <div class="hud-item"><div class="hud-label">Score</div><div class="hud-value score" id="hudScore">0</div></div>
  <div class="hud-item"><div class="hud-label">Level</div><div class="hud-value level" id="hudLevel">1</div></div>
  <div class="hud-item"><div class="hud-label">Time</div><div class="hud-value timer" id="hudTimer">90</div></div>
  <div class="hud-item"><div class="hud-label">Missed</div><div class="hud-value missed" id="hudMissed">0/15</div></div>
</div>

<div class="screen-overlay" id="startScreen">
  <div class="level-badge">UFCR GAMES</div>
  <div class="screen-title" style="color:var(--orange)">DEPORT</div>
  <p class="screen-sub">You're in the ICE helicopter patrolling the border zone. Spot illegal crossings and tap to dispatch agents before they escape into the city.</p>
  <ul class="instructions">
    <li>You patrol from above — the map scrolls automatically</li>
    <li>Runners appear and head toward the city</li>
    <li><strong>Tap or click</strong> on them to dispatch ICE</li>
    <li>Miss 15 and the border is breached</li>
    <li>They get faster and more frequent each level</li>
  </ul>
  <button class="btn" id="startBtn">Start Patrol</button>
</div>

<div class="screen-overlay hidden" id="gameOverScreen">
  <div class="level-badge">PATROL ENDED</div>
  <div class="screen-title" id="goTitle">Game Over</div>
  <div class="screen-stats" id="goStats"></div>
  <button class="btn" id="restartBtn">Patrol Again</button>
  <div class="share-btns">
    <button class="share-btn" id="shareBtn"><i class="fab fa-x-twitter"></i> Share</button>
    <button class="share-btn" id="copyBtn"><i class="fas fa-copy"></i> Copy</button>
  </div>
</div>

<canvas id="game"></canvas>

<script>
const C = document.getElementById('game');
const ctx = C.getContext('2d');

let W, H, dpr;
function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth; H = window.innerHeight;
  C.width = W * dpr; C.height = H * dpr;
  C.style.width = W + 'px'; C.style.height = H + 'px';
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// ─── CONSTANTS ───
const HUD_TOP = 92;
const MAX_MISSED = 15;
const GAME_TIME = 90;
const GOLD = '#F0A830', ORANGE = '#FA4616', RED = '#D32F2F';

// ─── STATE ───
let score=0, missed=0, level=1, timeLeft=GAME_TIME;
let totalDeported=0, combo=0, maxCombo=0;
let gameRunning=false, gameTimer=null;
let scrollY=0, runners=[], effects=[], dispatches=[];
let spawnAccum=0, lastTime=0;

// ─── TERRAIN SEED ───
// Pre-generate cactus, rock, and bush positions
const cacti = [], rocks = [], bushes = [];
for (let i = 0; i < 60; i++) {
  cacti.push({ x: Math.random(), y: Math.random() * 8000 - 4000, h: 14 + Math.random() * 12, type: Math.floor(Math.random()*3) });
}
for (let i = 0; i < 80; i++) {
  rocks.push({ x: Math.random(), y: Math.random() * 8000 - 4000, r: 3 + Math.random() * 5, shade: 0.15 + Math.random() * 0.1 });
}
for (let i = 0; i < 50; i++) {
  bushes.push({ x: Math.random(), y: Math.random() * 8000 - 4000, r: 5 + Math.random() * 8 });
}
// Buildings for city zone
const buildings = [];
for (let i = 0; i < 40; i++) {
  buildings.push({ x: Math.random(), y: -800 - Math.random() * 1200, w: 18 + Math.random() * 35, h: 22 + Math.random() * 40, shade: 0.3 + Math.random() * 0.2 });
}

// ─── LEVEL CONFIG ───
function getLevelConfig(lvl) {
  return {
    spawnInterval: Math.max(0.35, 1.4 - (lvl-1) * 0.11),
    runnerSpeed: 58 + (lvl-1) * 13,
    maxRunners: Math.min(22, 6 + lvl * 2),
  };
}

// ─── SPAWN ───
function spawnRunner() {
  const cfg = getLevelConfig(level);
  runners.push({
    x: 25 + Math.random() * (W - 50),
    y: scrollY + H + 40,
    speed: cfg.runnerSpeed * (0.8 + Math.random() * 0.4),
    size: 6,
    sway: (Math.random() - 0.5) * 0.7,
    phase: Math.random() * Math.PI * 2,
    alive: true,
    deported: false,
    deportAnim: 0,
    // Runner clothing tones (muted earth tones)
    shirtColor: `hsl(${20 + Math.random()*30}, ${15+Math.random()*15}%, ${35+Math.random()*20}%)`,
    pantsColor: `hsl(${210 + Math.random()*30}, ${10+Math.random()*10}%, ${25+Math.random()*15}%)`,
    skinTone: `hsl(${25 + Math.random()*15}, ${30+Math.random()*20}%, ${55+Math.random()*20}%)`,
    hatChance: Math.random() > 0.5,
    bagChance: Math.random() > 0.6,
    stride: 0,
  });
}

// ─── EFFECTS ───
function addEffect(x, y, text, color) { effects.push({ x, y, text, color, life: 1 }); }
function addDispatch(x, y) { dispatches.push({ x, y, life: 1 }); }

// ─── INPUT ───
function handleTap(cx, cy) {
  if (!gameRunning) return;
  const px = cx, py = cy + scrollY - HUD_TOP;
  let bestD = 36, bestI = -1;
  for (let i = 0; i < runners.length; i++) {
    const r = runners[i];
    if (!r.alive || r.deported) continue;
    const dx = r.x - px, dy = r.y - py;
    const d = Math.sqrt(dx*dx + dy*dy);
    if (d < bestD) { bestD = d; bestI = i; }
  }
  if (bestI >= 0) {
    const r = runners[bestI];
    r.deported = true; r.deportAnim = 0; r.alive = false;
    combo++; if (combo > maxCombo) maxCombo = combo;
    totalDeported++;
    const pts = 10 + (level-1)*5 + Math.floor(combo/3)*5;
    score += pts;
    const texts = ['DEPORTED','REMOVED','DISPATCHED','INTERCEPTED','CAUGHT','ICE\'D'];
    const label = combo >= 3 ? texts[Math.floor(Math.random()*texts.length)] + ' x' + combo : '+' + pts;
    addEffect(r.x, r.y, label, GOLD);
    addDispatch(r.x, r.y);
    updateHUD(); checkLevelUp();
  }
}
C.addEventListener('click', e => handleTap(e.clientX, e.clientY));
C.addEventListener('touchstart', e => { e.preventDefault(); handleTap(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

// ─── HUD ───
function updateHUD() {
  document.getElementById('hudScore').textContent = score;
  document.getElementById('hudLevel').textContent = level;
  document.getElementById('hudTimer').textContent = timeLeft;
  document.getElementById('hudMissed').textContent = missed + '/' + MAX_MISSED;
}
function checkLevelUp() {
  if (totalDeported >= level * 10) {
    level++;
    addEffect(W/2, scrollY + H/2, 'LEVEL ' + level, GOLD);
    updateHUD();
  }
}

// ─── DRAW: TERRAIN ───
function drawTerrain() {
  // Desert gradient
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, '#c2a67a');
  g.addColorStop(0.3, '#d4b98a');
  g.addColorStop(1, '#c8ad78');
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  // Subtle sand texture lines
  ctx.strokeStyle = 'rgba(180,155,110,0.25)';
  ctx.lineWidth = 1;
  const sandOff = (scrollY * 0.15) % 40;
  for (let y = -sandOff; y < H; y += 40) {
    ctx.beginPath();
    ctx.moveTo(0, y + Math.sin(y * 0.05) * 3);
    for (let x = 0; x < W; x += 20) {
      ctx.lineTo(x, y + Math.sin((x + scrollY) * 0.02) * 4);
    }
    ctx.stroke();
  }

  // City zone (top region)
  const fenceScreenY = -scrollY + HUD_TOP;
  const cityBottom = fenceScreenY - 80;
  if (cityBottom > -200) {
    // Concrete ground for city
    const cg = ctx.createLinearGradient(0, 0, 0, Math.max(0, cityBottom));
    cg.addColorStop(0, '#6b6b78');
    cg.addColorStop(1, '#8a8a90');
    ctx.fillStyle = cg;
    ctx.fillRect(0, 0, W, Math.max(0, cityBottom));

    // Buildings
    buildings.forEach(b => {
      const bx = b.x * W;
      const by = b.y - scrollY + HUD_TOP;
      if (by > -60 && by < H) {
        // Building body
        ctx.fillStyle = `rgba(60,60,75,${b.shade + 0.3})`;
        ctx.fillRect(bx - b.w/2, by - b.h, b.w, b.h);
        // Windows
        ctx.fillStyle = 'rgba(200,190,140,0.3)';
        for (let wy = by - b.h + 5; wy < by - 4; wy += 8) {
          for (let wx = bx - b.w/2 + 4; wx < bx + b.w/2 - 4; wx += 7) {
            ctx.fillRect(wx, wy, 4, 4);
          }
        }
        // Roof line
        ctx.fillStyle = 'rgba(40,40,55,0.5)';
        ctx.fillRect(bx - b.w/2 - 1, by - b.h - 2, b.w + 2, 3);
      }
    });

    // City label
    ctx.fillStyle = 'rgba(250,70,22,0.25)';
    ctx.font = '600 10px Oswald, sans-serif';
    ctx.textAlign = 'center';
    ctx.letterSpacing = '3px';
    ctx.fillText('CITY ZONE — DO NOT LET THEM REACH HERE', W/2, Math.max(20, cityBottom - 10));
  }

  // Rocks
  rocks.forEach(rk => {
    const rx = rk.x * W;
    const ry = rk.y - scrollY + HUD_TOP;
    if (ry < -20 || ry > H + 20) return;
    ctx.fillStyle = `rgba(140,125,100,${rk.shade})`;
    ctx.beginPath();
    ctx.ellipse(rx, ry, rk.r * 1.3, rk.r * 0.7, 0, 0, Math.PI * 2);
    ctx.fill();
  });

  // Bushes
  bushes.forEach(b => {
    const bx = b.x * W;
    const by = b.y - scrollY + HUD_TOP;
    if (by < -20 || by > H + 20) return;
    ctx.fillStyle = 'rgba(90,110,60,0.35)';
    ctx.beginPath();
    ctx.arc(bx, by, b.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(70,95,45,0.25)';
    ctx.beginPath();
    ctx.arc(bx + b.r * 0.3, by - b.r * 0.2, b.r * 0.7, 0, Math.PI * 2);
    ctx.fill();
  });

  // Cacti
  cacti.forEach(c => {
    const cx = c.x * W;
    const cy = c.y - scrollY + HUD_TOP;
    if (cy < -30 || cy > H + 30) return;
    const h = c.h;
    // Trunk
    ctx.fillStyle = 'rgba(55,85,45,0.6)';
    ctx.beginPath();
    ctx.roundRect(cx - 2.5, cy - h, 5, h, 2);
    ctx.fill();
    // Arms
    if (c.type === 0) {
      ctx.beginPath();
      ctx.roundRect(cx + 2, cy - h * 0.65, 8, 3, 1.5);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(cx + 7, cy - h * 0.65 - 7, 3, 10, 1.5);
      ctx.fill();
    } else if (c.type === 1) {
      ctx.beginPath();
      ctx.roundRect(cx - 10, cy - h * 0.5, 8, 3, 1.5);
      ctx.fill();
      ctx.beginPath();
      ctx.roundRect(cx - 10, cy - h * 0.5 - 6, 3, 9, 1.5);
      ctx.fill();
    }
  });

  // ─── BORDER FENCE ───
  if (fenceScreenY > -40 && fenceScreenY < H + 40) {
    // Ground strip
    ctx.fillStyle = 'rgba(100,85,65,0.3)';
    ctx.fillRect(0, fenceScreenY - 6, W, 12);

    // Steel posts
    for (let x = 20; x < W; x += 40) {
      // Post shadow
      ctx.fillStyle = 'rgba(0,0,0,0.1)';
      ctx.fillRect(x + 2, fenceScreenY - 22, 4, 44);
      // Post
      const pg = ctx.createLinearGradient(x - 2, 0, x + 4, 0);
      pg.addColorStop(0, '#9a9a9a');
      pg.addColorStop(0.5, '#d0d0d0');
      pg.addColorStop(1, '#888');
      ctx.fillStyle = pg;
      ctx.fillRect(x - 2, fenceScreenY - 24, 4, 48);
      // Post cap
      ctx.fillStyle = '#aaa';
      ctx.fillRect(x - 3, fenceScreenY - 26, 6, 3);
    }

    // Horizontal rails
    ctx.strokeStyle = '#aaa';
    ctx.lineWidth = 2;
    [-16, -6, 4, 14].forEach(off => {
      ctx.beginPath();
      ctx.moveTo(0, fenceScreenY + off);
      ctx.lineTo(W, fenceScreenY + off);
      ctx.stroke();
    });

    // Razor wire (top)
    ctx.strokeStyle = 'rgba(180,180,180,0.6)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x < W; x += 6) {
      const yy = fenceScreenY - 26 + Math.sin(x * 0.3) * 3;
      x === 0 ? ctx.moveTo(x, yy) : ctx.lineTo(x, yy);
    }
    ctx.stroke();
    // Wire barbs
    ctx.strokeStyle = 'rgba(160,160,160,0.4)';
    for (let x = 8; x < W; x += 12) {
      const yy = fenceScreenY - 26 + Math.sin(x * 0.3) * 3;
      ctx.beginPath(); ctx.moveTo(x, yy - 3); ctx.lineTo(x + 2, yy + 3); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(x, yy + 3); ctx.lineTo(x - 2, yy - 3); ctx.stroke();
    }

    // Label
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.font = '600 9px Oswald, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('U.S. BORDER', W/2, fenceScreenY + 32);
  }
}

// ─── DRAW: RUNNER (stylized human figure, no emoji) ───
function drawRunner(r) {
  const sx = r.x;
  const sy = r.y - scrollY + HUD_TOP;
  if (sy < -40 || sy > H + 40) return;

  if (r.deported) {
    const a = 1 - r.deportAnim;
    // Red ping
    ctx.beginPath();
    ctx.arc(sx, sy, 20 * r.deportAnim + 8, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(250,70,22,${a * 0.7})`;
    ctx.lineWidth = 2;
    ctx.stroke();
    // X mark
    ctx.strokeStyle = `rgba(250,70,22,${a})`;
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(sx-6, sy-6); ctx.lineTo(sx+6, sy+6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(sx+6, sy-6); ctx.lineTo(sx-6, sy+6); ctx.stroke();
    return;
  }

  const s = r.size;
  const stride = Math.sin(r.stride) * 3;

  // Drop shadow
  ctx.fillStyle = 'rgba(0,0,0,0.2)';
  ctx.beginPath();
  ctx.ellipse(sx, sy + s * 1.8, s * 1, s * 0.35, 0, 0, Math.PI * 2);
  ctx.fill();

  // Legs (animated stride)
  ctx.strokeStyle = r.pantsColor;
  ctx.lineWidth = 2.5;
  ctx.lineCap = 'round';
  // Left leg
  ctx.beginPath();
  ctx.moveTo(sx - 2, sy + s * 0.4);
  ctx.lineTo(sx - 2 + stride, sy + s * 1.6);
  ctx.stroke();
  // Right leg
  ctx.beginPath();
  ctx.moveTo(sx + 2, sy + s * 0.4);
  ctx.lineTo(sx + 2 - stride, sy + s * 1.6);
  ctx.stroke();

  // Torso
  ctx.fillStyle = r.shirtColor;
  ctx.beginPath();
  ctx.roundRect(sx - s * 0.6, sy - s * 0.5, s * 1.2, s * 1.1, 2);
  ctx.fill();

  // Arms (swinging)
  ctx.strokeStyle = r.skinTone;
  ctx.lineWidth = 2;
  // Left arm
  ctx.beginPath();
  ctx.moveTo(sx - s * 0.6, sy - s * 0.2);
  ctx.lineTo(sx - s * 1.1 - stride * 0.5, sy + s * 0.5);
  ctx.stroke();
  // Right arm
  ctx.beginPath();
  ctx.moveTo(sx + s * 0.6, sy - s * 0.2);
  ctx.lineTo(sx + s * 1.1 + stride * 0.5, sy + s * 0.5);
  ctx.stroke();

  // Backpack
  if (r.bagChance) {
    ctx.fillStyle = 'rgba(80,70,55,0.7)';
    ctx.beginPath();
    ctx.roundRect(sx - s * 0.8, sy - s * 0.3, s * 0.5, s * 0.7, 2);
    ctx.fill();
  }

  // Head
  ctx.fillStyle = r.skinTone;
  ctx.beginPath();
  ctx.arc(sx, sy - s * 0.9, s * 0.5, 0, Math.PI * 2);
  ctx.fill();

  // Hair/hat
  if (r.hatChance) {
    ctx.fillStyle = 'rgba(60,50,40,0.8)';
    ctx.beginPath();
    ctx.ellipse(sx, sy - s * 1.15, s * 0.6, s * 0.2, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillRect(sx - s * 0.35, sy - s * 1.4, s * 0.7, s * 0.35);
  } else {
    ctx.fillStyle = 'rgba(30,25,20,0.7)';
    ctx.beginPath();
    ctx.arc(sx, sy - s * 1.05, s * 0.45, Math.PI, 0);
    ctx.fill();
  }

  // Detection ring
  const pulse = Math.sin(Date.now() * 0.004 + r.phase) * 0.3 + 0.7;
  ctx.beginPath();
  ctx.arc(sx, sy, s * 2.5, 0, Math.PI * 2);
  ctx.strokeStyle = `rgba(250,70,22,${pulse * 0.2})`;
  ctx.lineWidth = 1;
  ctx.setLineDash([3, 4]);
  ctx.stroke();
  ctx.setLineDash([]);
}

// ─── DRAW: EFFECTS ───
function drawEffects() {
  ctx.textAlign = 'center';
  effects.forEach(e => {
    const sy = e.y - scrollY + HUD_TOP;
    const a = e.life;
    ctx.globalAlpha = a;
    ctx.fillStyle = e.color;
    ctx.font = `700 ${13 + (1-a)*6}px Oswald, sans-serif`;
    ctx.fillText(e.text, e.x, sy - (1-a)*35);
    ctx.globalAlpha = 1;
  });

  dispatches.forEach(d => {
    const sy = d.y - scrollY + HUD_TOP;
    const p = 1 - d.life;
    // Expanding ring
    ctx.beginPath();
    ctx.arc(d.x, sy, p * 30 + 5, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(250,70,22,${d.life * 0.6})`;
    ctx.lineWidth = 2;
    ctx.stroke();
    // Inner crosshair
    if (d.life > 0.4) {
      const ca = (d.life - 0.4) / 0.6;
      ctx.strokeStyle = `rgba(255,255,255,${ca * 0.5})`;
      ctx.lineWidth = 1;
      const len = 10;
      ctx.beginPath(); ctx.moveTo(d.x - len, sy); ctx.lineTo(d.x - 4, sy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(d.x + 4, sy); ctx.lineTo(d.x + len, sy); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(d.x, sy - len); ctx.lineTo(d.x, sy - 4); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(d.x, sy + 4); ctx.lineTo(d.x, sy + len); ctx.stroke();
    }
  });
}

// ─── DRAW: HELICOPTER OVERLAY ───
function drawHelicopterOverlay() {
  // Subtle spotlight
  const spotX = W/2 + Math.sin(Date.now() * 0.0008) * W * 0.15;
  const sg = ctx.createRadialGradient(spotX, H * 0.45, 0, spotX, H * 0.45, 180);
  sg.addColorStop(0, 'rgba(255,255,220,0.03)');
  sg.addColorStop(1, 'rgba(255,255,220,0)');
  ctx.fillStyle = sg;
  ctx.fillRect(0, 0, W, H);

  // Vignette
  const vg = ctx.createRadialGradient(W/2, H/2, H * 0.3, W/2, H/2, H * 0.75);
  vg.addColorStop(0, 'rgba(0,0,0,0)');
  vg.addColorStop(1, 'rgba(0,0,0,0.25)');
  ctx.fillStyle = vg;
  ctx.fillRect(0, 0, W, H);

  // ─── MINIMAP ───
  const mw = 40, mh = 90, mx = W - mw - 8, my = HUD_TOP + 8;
  ctx.fillStyle = 'rgba(0,0,0,0.45)';
  ctx.beginPath();
  ctx.roundRect(mx, my, mw, mh, 4);
  ctx.fill();
  ctx.strokeStyle = 'rgba(255,255,255,0.1)';
  ctx.lineWidth = 1;
  ctx.stroke();

  const mapRange = H * 4;
  const mapScale = mh / mapRange;
  const viewTop = scrollY * mapScale;

  // Viewport
  ctx.fillStyle = 'rgba(250,70,22,0.2)';
  ctx.fillRect(mx + 2, my + 2 + viewTop, mw - 4, H * mapScale);

  // Fence on minimap
  const fmapY = my + 2 + (-scrollY + HUD_TOP) * mapScale + (0) * mapScale;
  // approximate
  const fmy = my + mh * 0.5;
  ctx.strokeStyle = 'rgba(255,255,255,0.3)';
  ctx.beginPath(); ctx.moveTo(mx + 4, fmy); ctx.lineTo(mx + mw - 4, fmy); ctx.stroke();

  // Runners on minimap
  runners.forEach(r => {
    if (!r.alive) return;
    const rmx = mx + 2 + (r.x / W) * (mw - 4);
    const rmy = my + 2 + (r.y - scrollY) * mapScale + mh * 0.3;
    if (rmy > my && rmy < my + mh) {
      ctx.fillStyle = '#ff5533';
      ctx.beginPath();
      ctx.arc(rmx, rmy, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  });

  // Scan line overlay
  const scanY = (Date.now() * 0.04) % H;
  ctx.strokeStyle = 'rgba(100,255,140,0.04)';
  ctx.lineWidth = 1;
  ctx.beginPath(); ctx.moveTo(0, scanY); ctx.lineTo(W, scanY); ctx.stroke();
}

// ─── GAME LOOP ───
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;

  if (gameRunning) {
    scrollY -= dt * (28 + level * 5);
    const minScroll = -H * 2;
    if (scrollY < minScroll) scrollY = minScroll;

    const cfg = getLevelConfig(level);
    spawnAccum += dt;
    if (spawnAccum >= cfg.spawnInterval && runners.filter(r=>r.alive).length < cfg.maxRunners) {
      spawnRunner();
      spawnAccum = 0;
    }

    runners.forEach(r => {
      if (r.deported) { r.deportAnim += dt * 3; if (r.deportAnim >= 1) r.deported = false; return; }
      if (!r.alive) return;
      r.y -= r.speed * dt;
      r.x += Math.sin(r.phase + r.y * 0.008) * r.sway;
      r.x = Math.max(12, Math.min(W - 12, r.x));
      r.stride += dt * 8;
      if (r.y < -900) {
        r.alive = false; missed++; combo = 0;
        addEffect(r.x, r.y, 'ESCAPED', RED);
        updateHUD();
        if (missed >= MAX_MISSED) endGame();
      }
    });

    runners = runners.filter(r => r.alive || r.deported);
    effects.forEach(e => e.life -= dt * 1.4);
    effects = effects.filter(e => e.life > 0);
    dispatches.forEach(d => d.life -= dt * 2);
    dispatches = dispatches.filter(d => d.life > 0);
  }

  ctx.clearRect(0, 0, W, H);
  drawTerrain();
  runners.forEach(r => drawRunner(r));
  drawEffects();
  if (gameRunning) drawHelicopterOverlay();

  requestAnimationFrame(loop);
}

// ─── START / END ───
function startGame() {
  score=0; missed=0; level=1; timeLeft=GAME_TIME;
  combo=0; maxCombo=0; totalDeported=0;
  runners=[]; effects=[]; dispatches=[]; spawnAccum=0;
  scrollY = H * 0.5;
  gameRunning = true;
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');
  updateHUD();
  clearInterval(gameTimer);
  gameTimer = setInterval(() => { timeLeft--; updateHUD(); if (timeLeft <= 0) endGame(); }, 1000);
}

function endGame() {
  gameRunning = false; clearInterval(gameTimer);
  const t = document.getElementById('goTitle');
  if (missed >= MAX_MISSED) { t.textContent = 'Border Breached'; t.style.color = RED; }
  else { t.textContent = 'Patrol Complete'; t.style.color = GOLD; }
  document.getElementById('goStats').innerHTML = `
    <div class="stat-row"><span class="stat-label">Score</span><span class="stat-val">${score}</span></div>
    <div class="stat-row"><span class="stat-label">Deported</span><span class="stat-val">${totalDeported}</span></div>
    <div class="stat-row"><span class="stat-label">Escaped</span><span class="stat-val">${missed}</span></div>
    <div class="stat-row"><span class="stat-label">Max Level</span><span class="stat-val">${level}</span></div>
    <div class="stat-row"><span class="stat-label">Best Combo</span><span class="stat-val">x${maxCombo}</span></div>`;
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

function shareText() {
  return `DEPORT — ICE Patrol\n\nScore: ${score}\nDeported: ${totalDeported}\nEscaped: ${missed}\nLevel ${level} | x${maxCombo} combo\n\nPatrol the border: ufcr.online/deport/`;
}

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);
document.getElementById('shareBtn').addEventListener('click', () => {
  window.open('https://x.com/intent/tweet?text=' + encodeURIComponent(shareText()), '_blank');
});
document.getElementById('copyBtn').addEventListener('click', () => {
  navigator.clipboard.writeText(shareText()).then(() => {
    document.getElementById('copyBtn').innerHTML = '<i class="fas fa-check"></i> Copied!';
    setTimeout(() => { document.getElementById('copyBtn').innerHTML = '<i class="fas fa-copy"></i> Copy'; }, 2000);
  });
});

requestAnimationFrame(loop);
</script>
</body>
</html>
