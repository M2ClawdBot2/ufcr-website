<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>DEPORT — Tower Defense | UFCR</title>
  <link rel="icon" href="../assets/images/shield-logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Oswald:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <style>
    :root {
      --navy: #001845;
      --dark: #0A0E1A;
      --orange: #FA4616;
      --gold: #F0A830;
      --white: #FFFFFF;
      --blue: #0021A5;
      --font-body: 'Inter', -apple-system, sans-serif;
      --font-heading: 'Oswald', 'Inter', sans-serif;
    }
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body { font-family: var(--font-body); background: var(--dark); color: var(--white); }
    a { text-decoration: none; color: inherit; }

    /* NAV */
    .nav { position: fixed; top: 0; left: 0; right: 0; height: 56px; background: var(--navy); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; z-index: 1000; border-bottom: 2px solid var(--orange); }
    .nav-logo { display: flex; align-items: center; gap: 10px; font-family: var(--font-heading); font-size: 1.2rem; font-weight: 700; letter-spacing: 1px; }
    .nav-logo img { height: 32px; }
    .nav-back { font-family: var(--font-heading); font-size: 0.85rem; font-weight: 600; letter-spacing: 1px; text-transform: uppercase; color: var(--gold); transition: color 0.2s; }
    .nav-back:hover { color: var(--orange); }
    .nav-back i { margin-right: 6px; }

    /* GAME WRAPPER */
    #game-wrapper { position: fixed; top: 56px; left: 0; right: 0; bottom: 0; display: flex; flex-direction: column; background: var(--dark); }

    /* TOP HUD */
    #hud-top { height: 44px; background: rgba(0,24,69,0.95); display: flex; align-items: center; justify-content: center; gap: 30px; padding: 0 16px; border-bottom: 1px solid rgba(250,70,22,0.3); font-family: var(--font-heading); font-size: 0.9rem; letter-spacing: 1px; flex-shrink: 0; }
    .hud-item { display: flex; align-items: center; gap: 6px; }
    .hud-item i { color: var(--gold); font-size: 0.85rem; }
    .hud-item span { color: var(--white); font-weight: 600; }
    .hud-val { color: var(--orange) !important; }

    /* CANVAS */
    #game-canvas { flex: 1; display: block; cursor: crosshair; }

    /* BOTTOM BAR */
    #hud-bottom { height: 72px; background: rgba(0,24,69,0.95); display: flex; align-items: center; justify-content: center; gap: 8px; padding: 0 12px; border-top: 1px solid rgba(250,70,22,0.3); flex-shrink: 0; overflow-x: auto; }
    .unit-btn { display: flex; flex-direction: column; align-items: center; justify-content: center; width: 72px; height: 60px; background: rgba(255,255,255,0.05); border: 2px solid rgba(255,255,255,0.15); cursor: pointer; font-family: var(--font-heading); transition: all 0.15s; position: relative; user-select: none; -webkit-tap-highlight-color: transparent; }
    .unit-btn:hover { border-color: var(--gold); background: rgba(240,168,48,0.1); }
    .unit-btn.selected { border-color: var(--orange); background: rgba(250,70,22,0.2); }
    .unit-btn.disabled { opacity: 0.35; pointer-events: none; }
    .unit-btn i { font-size: 1.1rem; margin-bottom: 2px; }
    .unit-btn .unit-name { font-size: 0.55rem; letter-spacing: 0.5px; text-transform: uppercase; }
    .unit-btn .unit-cost { font-size: 0.6rem; color: var(--gold); font-weight: 700; }

    /* MENU OVERLAYS */
    .overlay { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; background: rgba(10,14,26,0.95); z-index: 100; overflow-y: auto; }
    .overlay.hidden { display: none; }
    .overlay.overlay-center { justify-content: center; }
    .menu-title { font-family: var(--font-heading); font-size: 4rem; font-weight: 700; letter-spacing: 6px; color: var(--orange); text-transform: uppercase; line-height: 1; }
    .menu-subtitle { font-family: var(--font-heading); font-size: 1.2rem; letter-spacing: 4px; color: var(--gold); text-transform: uppercase; margin-top: 8px; }
    .menu-btn { font-family: var(--font-heading); font-size: 1rem; font-weight: 600; letter-spacing: 2px; text-transform: uppercase; padding: 14px 40px; border: 2px solid var(--orange); background: transparent; color: var(--white); cursor: pointer; margin-top: 16px; transition: all 0.2s; }
    .menu-btn:hover { background: var(--orange); color: var(--dark); }
    .menu-btn.primary { background: var(--orange); color: var(--white); }
    .menu-btn.primary:hover { background: #ff5a2e; }
    .menu-btn i { margin-right: 8px; }

    /* LEVEL SELECT */
    #levelselect-overlay { padding: 20px 16px 40px; }
    .ls-header { text-align: center; margin-bottom: 24px; flex-shrink: 0; }
    .level-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 560px; width: 100%; }
    .level-card { background: rgba(255,255,255,0.04); border: 2px solid rgba(255,255,255,0.1); padding: 16px; cursor: pointer; transition: all 0.2s; position: relative; }
    .level-card:hover:not(.locked) { border-color: var(--orange); background: rgba(250,70,22,0.08); }
    .level-card.locked { opacity: 0.4; cursor: not-allowed; }
    .level-card .lc-num { font-family: var(--font-heading); font-size: 0.7rem; letter-spacing: 2px; color: var(--gold); text-transform: uppercase; margin-bottom: 4px; }
    .level-card .lc-name { font-family: var(--font-heading); font-size: 1.1rem; font-weight: 700; letter-spacing: 1px; color: var(--white); margin-bottom: 6px; }
    .level-card .lc-info { font-size: 0.7rem; color: rgba(255,255,255,0.5); margin-bottom: 8px; }
    .level-card .lc-stars { display: flex; gap: 4px; }
    .level-card .lc-stars i { font-size: 0.85rem; color: rgba(255,255,255,0.15); }
    .level-card .lc-stars i.earned { color: var(--gold); }
    .level-card .lc-lock { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; color: rgba(255,255,255,0.3); }
    .level-card .lc-highscore { font-size: 0.65rem; color: rgba(255,255,255,0.35); margin-top: 4px; font-family: var(--font-heading); letter-spacing: 1px; }
    .ls-footer { margin-top: 20px; text-align: center; flex-shrink: 0; }
    .ls-total-stars { font-family: var(--font-heading); font-size: 0.85rem; color: var(--gold); letter-spacing: 1px; margin-bottom: 12px; }

    /* HOW TO PLAY */
    .howto-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; max-width: 420px; margin-top: 16px; }
    .howto-item { display: flex; align-items: flex-start; gap: 8px; font-size: 0.75rem; color: rgba(255,255,255,0.8); line-height: 1.4; }
    .howto-item i { color: var(--orange); margin-top: 2px; min-width: 16px; }

    /* WAVE BANNER */
    #wave-banner { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: var(--font-heading); font-size: 2rem; letter-spacing: 4px; color: var(--gold); text-transform: uppercase; pointer-events: none; opacity: 0; z-index: 50; text-shadow: 0 2px 20px rgba(0,0,0,0.8); }

    /* GAME OVER / LEVEL COMPLETE */
    .stat-row { font-family: var(--font-heading); font-size: 1rem; letter-spacing: 1px; margin: 6px 0; }
    .stat-val { color: var(--orange); font-weight: 700; }
    .stars-display { display: flex; gap: 8px; margin: 16px 0; }
    .stars-display i { font-size: 2rem; color: rgba(255,255,255,0.15); transition: color 0.3s, transform 0.3s; }
    .stars-display i.earned { color: var(--gold); transform: scale(1.2); }
    .btn-row { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; margin-top: 16px; }
    .btn-row .menu-btn { margin-top: 0; padding: 12px 24px; font-size: 0.85rem; }

    @media (max-width: 600px) {
      .menu-title { font-size: 2.5rem; letter-spacing: 3px; }
      .menu-subtitle { font-size: 0.9rem; }
      #hud-top { gap: 12px; font-size: 0.75rem; }
      .unit-btn { width: 60px; height: 52px; }
      .howto-grid { grid-template-columns: 1fr; }
      .level-grid { grid-template-columns: 1fr 1fr; gap: 8px; }
      .level-card { padding: 12px; }
      .level-card .lc-name { font-size: 0.95rem; }
    }
  </style>
</head>
<body>

  <!-- NAV -->
  <nav class="nav">
    <a href="../" class="nav-logo">
      <img src="../assets/images/shield-logo.png" alt="UFCR">
      <span>UFCR</span>
    </a>
    <a href="../games/" class="nav-back"><i class="fas fa-arrow-left"></i> Back to Games</a>
  </nav>

  <div id="game-wrapper">
    <!-- TOP HUD -->
    <div id="hud-top" style="display:none;">
      <div class="hud-item"><i class="fas fa-flag"></i> <span>WAVE</span> <span class="hud-val" id="hud-wave">1/3</span></div>
      <div class="hud-item"><i class="fas fa-dollar-sign"></i> <span class="hud-val" id="hud-money">500</span></div>
      <div class="hud-item"><i class="fas fa-heart"></i> <span>LIVES</span> <span class="hud-val" id="hud-lives">10</span></div>
      <div class="hud-item"><i class="fas fa-star"></i> <span>SCORE</span> <span class="hud-val" id="hud-score">0</span></div>
    </div>

    <!-- CANVAS -->
    <canvas id="game-canvas"></canvas>

    <!-- BOTTOM BAR -->
    <div id="hud-bottom" style="display:none;">
      <div class="unit-btn" data-unit="ice" title="ICE Agent — $50">
        <i class="fas fa-shield-halved" style="color:#4a9eff"></i>
        <span class="unit-name">ICE</span>
        <span class="unit-cost">$50</span>
      </div>
      <div class="unit-btn" data-unit="wall" title="Wall Segment — $75">
        <i class="fas fa-cube" style="color:#c8874a"></i>
        <span class="unit-name">Wall</span>
        <span class="unit-cost">$75</span>
      </div>
      <div class="unit-btn" data-unit="drone" title="Drone — $100">
        <i class="fas fa-jet-fighter" style="color:#aaa"></i>
        <span class="unit-name">Drone</span>
        <span class="unit-cost">$100</span>
      </div>
      <div class="unit-btn" data-unit="tower" title="Watchtower — $150">
        <i class="fas fa-tower-observation" style="color:#F0A830"></i>
        <span class="unit-name">Tower</span>
        <span class="unit-cost">$150</span>
      </div>
      <div class="unit-btn" data-unit="bus" title="Deportation Bus — $200">
        <i class="fas fa-bus" style="color:#4a9eff"></i>
        <span class="unit-name">Bus</span>
        <span class="unit-cost">$200</span>
      </div>
    </div>

    <!-- WAVE BANNER -->
    <div id="wave-banner"></div>

    <!-- LEVEL SELECT -->
    <div class="overlay" id="levelselect-overlay">
      <div class="ls-header">
        <div class="menu-title" id="ls-title">DEPORT</div>
        <div class="menu-subtitle">Defend the Border</div>
      </div>
      <div class="level-grid" id="level-grid"></div>
      <div class="ls-footer">
        <div class="ls-total-stars" id="ls-total-stars"></div>
        <button class="menu-btn" id="btn-howto"><i class="fas fa-question-circle"></i> How to Play</button>
      </div>
    </div>

    <!-- HOW TO PLAY -->
    <div class="overlay overlay-center hidden" id="howto-overlay">
      <div class="menu-title" style="font-size:2rem;">How to Play</div>
      <div class="howto-grid">
        <div class="howto-item"><i class="fas fa-mouse-pointer"></i> Select a defense unit from the bottom bar, then click on the map to place it.</div>
        <div class="howto-item"><i class="fas fa-route"></i> Enemies walk from left to right along the path. Stop them before they cross!</div>
        <div class="howto-item"><i class="fas fa-shield-halved"></i> ICE Agents catch enemies one at a time. Drones slow groups. Walls block paths.</div>
        <div class="howto-item"><i class="fas fa-bus"></i> The Deportation Bus removes multiple enemies at once but has a long cooldown.</div>
        <div class="howto-item"><i class="fas fa-tower-observation"></i> Watchtowers reveal tunnel paths and boost nearby ICE Agents.</div>
        <div class="howto-item"><i class="fas fa-heart-crack"></i> If 10 enemies get through, it's game over. Earn money for each catch.</div>
      </div>
      <button class="menu-btn" id="btn-howto-back" style="margin-top:24px;"><i class="fas fa-arrow-left"></i> Back</button>
    </div>

    <!-- LEVEL COMPLETE -->
    <div class="overlay overlay-center hidden" id="complete-overlay">
      <div class="menu-title" style="font-size:2.5rem;" id="complete-title">Level Complete</div>
      <div class="stars-display" id="complete-stars">
        <i class="fas fa-star"></i><i class="fas fa-star"></i><i class="fas fa-star"></i>
      </div>
      <div style="text-align:center;">
        <div class="stat-row"><i class="fas fa-star" style="color:var(--gold);margin-right:8px;"></i> Score: <span class="stat-val" id="lc-score">0</span></div>
        <div class="stat-row"><i class="fas fa-handcuffs" style="color:var(--gold);margin-right:8px;"></i> Deportations: <span class="stat-val" id="lc-deports">0</span></div>
        <div class="stat-row"><i class="fas fa-heart" style="color:var(--gold);margin-right:8px;"></i> Lives Remaining: <span class="stat-val" id="lc-lives">0</span></div>
      </div>
      <div class="btn-row">
        <button class="menu-btn primary" id="btn-nextlevel"><i class="fas fa-forward"></i> Next Level</button>
        <button class="menu-btn" id="btn-replay-win"><i class="fas fa-redo"></i> Replay</button>
        <button class="menu-btn" id="btn-levelselect-win"><i class="fas fa-th"></i> Level Select</button>
        <button class="menu-btn" id="btn-share-win"><i class="fas fa-share-alt"></i> Share</button>
      </div>
    </div>

    <!-- GAME OVER -->
    <div class="overlay overlay-center hidden" id="gameover-overlay">
      <div class="menu-title" style="font-size:2.5rem;">Game Over</div>
      <div style="margin-top:20px; text-align:center;">
        <div class="stat-row"><i class="fas fa-star" style="color:var(--gold);margin-right:8px;"></i> Score: <span class="stat-val" id="go-score">0</span></div>
        <div class="stat-row"><i class="fas fa-flag" style="color:var(--gold);margin-right:8px;"></i> Waves Survived: <span class="stat-val" id="go-waves">0</span></div>
        <div class="stat-row"><i class="fas fa-handcuffs" style="color:var(--gold);margin-right:8px;"></i> Deportations: <span class="stat-val" id="go-deports">0</span></div>
      </div>
      <div class="btn-row">
        <button class="menu-btn primary" id="btn-retry"><i class="fas fa-redo"></i> Retry Level</button>
        <button class="menu-btn" id="btn-levelselect-lose"><i class="fas fa-th"></i> Level Select</button>
        <button class="menu-btn" id="btn-share-lose"><i class="fas fa-share-alt"></i> Share</button>
      </div>
    </div>
  </div>

<script>
(function() {
  'use strict';

  // === CONSTANTS ===
  const GRID = 40;
  const COLORS = {
    sand1: '#E8D5A3', sand2: '#D4BC82', sand3: '#C4A86B',
    path: '#C8A96E', pathDark: '#B8955A',
    border: '#FA4616', usSide: 'rgba(0,24,69,0.15)',
    grid: 'rgba(255,255,255,0.06)',
    navy: '#001845', dark: '#0A0E1A', orange: '#FA4616', gold: '#F0A830'
  };

  const UNIT_DEFS = {
    ice:   { cost: 50,  range: 120, rate: 60,  color: '#4a9eff', icon: 'shield', shape: 'circle', dmg: 1, aoe: false },
    drone: { cost: 100, range: 200, rate: 90,  color: '#888',    icon: 'tri',    shape: 'tri',    dmg: 0.3, aoe: true, slow: 0.5 },
    wall:  { cost: 75,  range: 0,   rate: 0,   color: '#c8874a', icon: 'wall',   shape: 'rect',   hp: 10, blocks: true },
    bus:   { cost: 200, range: 140, rate: 180, color: '#4a9eff', icon: 'bus',    shape: 'bigrect', dmg: 3, aoe: true },
    tower: { cost: 150, range: 160, rate: 120, color: '#F0A830', icon: 'tower',  shape: 'diamond', dmg: 0.5, boost: true, reveals: true }
  };

  // === LEVEL DEFINITIONS ===
  const LEVELS = [
    {
      id: 1, name: 'Welcome to the Border', waves: 3, money: 800,
      desc: 'Tutorial — Learn the basics',
      waveGen: (w) => ({
        count: 4 + w * 2,
        spawnInterval: 55,
        enemyHp: 1.5 + w * 0.3,
        enemySpeed: 0.7 + w * 0.05,
        coyoteChance: 0,
        tunnelChance: 0
      })
    },
    {
      id: 2, name: 'Night Shift', waves: 4, money: 600,
      desc: 'Faster enemies approaching',
      waveGen: (w) => ({
        count: 5 + w * 2,
        spawnInterval: 48,
        enemyHp: 2 + w * 0.4,
        enemySpeed: 0.9 + w * 0.08,
        coyoteChance: 0,
        tunnelChance: 0
      })
    },
    {
      id: 3, name: 'Tunnel Rats', waves: 4, money: 600,
      desc: 'Tunnel enemies — watchtowers reveal them',
      waveGen: (w) => ({
        count: 5 + w * 2,
        spawnInterval: 50,
        enemyHp: 2.2 + w * 0.4,
        enemySpeed: 0.85 + w * 0.06,
        coyoteChance: 0,
        tunnelChance: 0.3 + w * 0.1
      })
    },
    {
      id: 4, name: 'Caravan Incoming', waves: 5, money: 700,
      desc: 'Large groups per wave',
      waveGen: (w) => ({
        count: 10 + w * 4,
        spawnInterval: 35,
        enemyHp: 2 + w * 0.35,
        enemySpeed: 0.8 + w * 0.05,
        coyoteChance: 0.05,
        tunnelChance: 0
      })
    },
    {
      id: 5, name: 'Coyote Country', waves: 5, money: 650,
      desc: 'Tough coyote leaders',
      waveGen: (w) => ({
        count: 6 + w * 2,
        spawnInterval: 45,
        enemyHp: 2.5 + w * 0.5,
        enemySpeed: 0.8 + w * 0.06,
        coyoteChance: 0.25 + w * 0.05,
        tunnelChance: 0
      })
    },
    {
      id: 6, name: 'Rush Hour', waves: 5, money: 700,
      desc: 'Very fast enemies, short intervals',
      waveGen: (w) => ({
        count: 8 + w * 3,
        spawnInterval: 22,
        enemyHp: 1.8 + w * 0.3,
        enemySpeed: 1.3 + w * 0.12,
        coyoteChance: 0.08,
        tunnelChance: 0.05
      })
    },
    {
      id: 7, name: 'The Surge', waves: 6, money: 750,
      desc: 'Massive numbers',
      waveGen: (w) => ({
        count: 12 + w * 5,
        spawnInterval: 28,
        enemyHp: 2.5 + w * 0.4,
        enemySpeed: 0.9 + w * 0.07,
        coyoteChance: 0.1 + w * 0.02,
        tunnelChance: 0.05
      })
    },
    {
      id: 8, name: 'Tunnel Network', waves: 6, money: 700,
      desc: 'Heavy tunnel usage — watchtowers essential',
      waveGen: (w) => ({
        count: 8 + w * 3,
        spawnInterval: 38,
        enemyHp: 2.8 + w * 0.5,
        enemySpeed: 0.85 + w * 0.07,
        coyoteChance: 0.1,
        tunnelChance: 0.5 + w * 0.05
      })
    },
    {
      id: 9, name: 'All Hands on Deck', waves: 7, money: 800,
      desc: 'Everything at once',
      waveGen: (w) => ({
        count: 10 + w * 4,
        spawnInterval: 26,
        enemyHp: 3 + w * 0.5,
        enemySpeed: 1.0 + w * 0.1,
        coyoteChance: 0.2 + w * 0.03,
        tunnelChance: 0.25 + w * 0.05
      })
    },
    {
      id: 10, name: 'Operation Secure', waves: 8, money: 900,
      desc: 'Maximum difficulty — Boss coyote in final wave',
      waveGen: (w, totalWaves) => ({
        count: 12 + w * 5,
        spawnInterval: 22,
        enemyHp: 3.5 + w * 0.6,
        enemySpeed: 1.1 + w * 0.1,
        coyoteChance: 0.2 + w * 0.04,
        tunnelChance: 0.2 + w * 0.05,
        boss: w === totalWaves
      })
    }
  ];

  // === PERSISTENCE ===
  function loadProgress() {
    try {
      const data = JSON.parse(localStorage.getItem('deport_progress'));
      if (data && data.levels) return data;
    } catch {}
    return { levels: { 1: { unlocked: true, stars: 0, highScore: 0 } } };
  }

  function saveProgress() {
    localStorage.setItem('deport_progress', JSON.stringify(progress));
  }

  let progress = loadProgress();

  function getLevelProgress(id) {
    return progress.levels[id] || { unlocked: false, stars: 0, highScore: 0 };
  }

  function completeLevel(id, stars, sc) {
    if (!progress.levels[id]) progress.levels[id] = { unlocked: true, stars: 0, highScore: 0 };
    const lp = progress.levels[id];
    if (stars > lp.stars) lp.stars = stars;
    if (sc > lp.highScore) lp.highScore = sc;
    // Unlock next
    if (id < 10) {
      if (!progress.levels[id + 1]) progress.levels[id + 1] = { unlocked: true, stars: 0, highScore: 0 };
      else progress.levels[id + 1].unlocked = true;
    }
    saveProgress();
  }

  // === STATE ===
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  let W, H, cols, rows;
  let gameState = 'menu'; // menu, playing, wavepause, gameover, complete
  let money, lives, score, deportations;
  let currentLevel = null; // LEVELS[index]
  let currentWave = 0; // 1-indexed current wave within level
  let enemies = [], towers = [], projectiles = [], particles = [];
  let selectedUnit = null;
  let path = [];
  let pathSet = new Set();
  let towerGrid = {};
  let waveEnemiesLeft = 0, waveSpawnTimer = 0;
  let wavePauseTimer = 0;
  let mouseGX = -1, mouseGY = -1;
  let animFrame = 0;
  let waveConfig = null;

  // === RESIZE ===
  function resize() {
    const wrapper = document.getElementById('game-wrapper');
    const hudTop = document.getElementById('hud-top');
    const hudBot = document.getElementById('hud-bottom');
    const topH = hudTop.style.display === 'none' ? 0 : 44;
    const botH = hudBot.style.display === 'none' ? 0 : 72;
    W = wrapper.clientWidth;
    H = wrapper.clientHeight - topH - botH;
    canvas.width = W;
    canvas.height = H;
    cols = Math.floor(W / GRID);
    rows = Math.floor(H / GRID);
    buildPath();
  }

  // === PATH BUILDING ===
  function buildPath(seed) {
    path = [];
    pathSet = new Set();
    if (rows < 3 || cols < 5) return;

    let y = Math.floor(rows / 2);
    const s0 = seed || (cols * 7 + rows * 13);
    const segCount = Math.max(3, Math.floor(cols / 6));
    const segWidth = Math.floor(cols / segCount);

    for (let s = 0; s < segCount; s++) {
      const startX = s * segWidth;
      const endX = s === segCount - 1 ? cols - 1 : (s + 1) * segWidth;
      const offsetY = ((s0 * (s + 1) * 37) % 5) - 2;
      const baseTarget = s % 2 === 0 ? Math.floor(rows * 0.25) : Math.floor(rows * 0.75);
      const targetY = Math.max(1, Math.min(rows - 2, baseTarget + offsetY));
      const midX = Math.floor((startX + endX) / 2);
      for (let px = startX; px <= midX; px++) path.push({ x: px, y });
      const dir = targetY > y ? 1 : -1;
      for (let py = y + dir; py !== targetY + dir; py += dir) path.push({ x: midX, y: py });
      y = targetY;
      for (let px = midX + 1; px <= endX; px++) path.push({ x: px, y });
    }
    for (let px = path[path.length - 1].x + 1; px < cols; px++) path.push({ x: px, y });

    const seen = new Set();
    path = path.filter(p => {
      const k = p.x + ',' + p.y;
      if (seen.has(k)) return false;
      seen.add(k);
      return true;
    });
    pathSet = new Set(path.map(p => p.x + ',' + p.y));
  }

  // === DRAWING ===
  function drawBackground() {
    const grd = ctx.createLinearGradient(0, 0, W, 0);
    grd.addColorStop(0, COLORS.sand1);
    grd.addColorStop(0.45, COLORS.sand2);
    grd.addColorStop(0.55, COLORS.sand3);
    grd.addColorStop(1, COLORS.sand2);
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, W, H);

    ctx.fillStyle = COLORS.usSide;
    ctx.fillRect(W * 0.5, 0, W * 0.5, H);

    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 0.5;
    for (let x = 0; x < W; x += GRID) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, H); ctx.stroke(); }
    for (let y = 0; y < H; y += GRID) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke(); }

    ctx.save();
    ctx.setLineDash([12, 8]);
    ctx.strokeStyle = COLORS.border;
    ctx.lineWidth = 2;
    ctx.globalAlpha = 0.6;
    ctx.beginPath();
    ctx.moveTo(W * 0.5, 0);
    ctx.lineTo(W * 0.5, H);
    ctx.stroke();
    ctx.restore();

    drawCacti();
  }

  function drawCacti() {
    ctx.fillStyle = '#5a7a3a';
    const seed = cols * 7 + rows * 13;
    for (let i = 0; i < 8; i++) {
      const cx = ((seed * (i + 1) * 37) % (cols - 2) + 1) * GRID + GRID / 2;
      const cy = ((seed * (i + 1) * 53) % (rows - 2) + 1) * GRID + GRID / 2;
      const gk = Math.floor(cx / GRID) + ',' + Math.floor(cy / GRID);
      if (pathSet.has(gk)) continue;
      ctx.globalAlpha = 0.4;
      ctx.fillRect(cx - 2, cy - 12, 4, 16);
      ctx.fillRect(cx - 8, cy - 8, 6, 3);
      ctx.fillRect(cx + 2, cy - 5, 6, 3);
      ctx.globalAlpha = 1;
    }
  }

  function drawPath() {
    ctx.fillStyle = COLORS.path;
    for (const p of path) ctx.fillRect(p.x * GRID, p.y * GRID, GRID, GRID);
    ctx.strokeStyle = COLORS.pathDark;
    ctx.lineWidth = 1;
    for (const p of path) {
      const x = p.x * GRID, y = p.y * GRID;
      if (!pathSet.has(p.x + ',' + (p.y - 1))) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + GRID, y); ctx.stroke(); }
      if (!pathSet.has(p.x + ',' + (p.y + 1))) { ctx.beginPath(); ctx.moveTo(x, y + GRID); ctx.lineTo(x + GRID, y + GRID); ctx.stroke(); }
    }
  }

  function drawPlacementPreview() {
    if (!selectedUnit || mouseGX < 0 || mouseGY < 0) return;
    const key = mouseGX + ',' + mouseGY;
    const onPath = pathSet.has(key);
    const occupied = towerGrid[key];
    const def = UNIT_DEFS[selectedUnit];
    const canPlace = !occupied && (def.blocks ? onPath : !onPath) && money >= def.cost;

    ctx.globalAlpha = 0.4;
    ctx.fillStyle = canPlace ? '#00ff00' : '#ff0000';
    ctx.fillRect(mouseGX * GRID, mouseGY * GRID, GRID, GRID);

    if (canPlace && def.range > 0) {
      ctx.strokeStyle = 'rgba(255,255,255,0.2)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(mouseGX * GRID + GRID / 2, mouseGY * GRID + GRID / 2, def.range, 0, Math.PI * 2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  function drawTower(t) {
    const cx = t.gx * GRID + GRID / 2;
    const cy = t.gy * GRID + GRID / 2;
    const def = UNIT_DEFS[t.type];
    const r = GRID * 0.4;

    ctx.fillStyle = def.color;
    ctx.strokeStyle = 'rgba(0,0,0,0.3)';
    ctx.lineWidth = 2;

    switch (def.shape) {
      case 'circle':
        ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(cx - 4, cy - 2); ctx.lineTo(cx, cy - 7); ctx.lineTo(cx + 4, cy - 2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(cx - 5, cy + 1); ctx.lineTo(cx + 5, cy + 1); ctx.stroke();
        break;
      case 'tri':
        ctx.beginPath(); ctx.moveTo(cx, cy - r); ctx.lineTo(cx - r, cy + r * 0.7); ctx.lineTo(cx + r, cy + r * 0.7); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = '#ddd'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(cx - 6, cy - 2); ctx.lineTo(cx + 6, cy - 2); ctx.stroke();
        break;
      case 'rect':
        ctx.fillRect(t.gx * GRID + 2, t.gy * GRID + 2, GRID - 4, GRID - 4);
        ctx.strokeRect(t.gx * GRID + 2, t.gy * GRID + 2, GRID - 4, GRID - 4);
        if (def.hp) {
          const hpPct = t.hp / def.hp;
          ctx.fillStyle = '#333'; ctx.fillRect(t.gx * GRID + 4, t.gy * GRID + GRID - 8, GRID - 8, 4);
          ctx.fillStyle = hpPct > 0.5 ? '#4caf50' : hpPct > 0.25 ? '#ff9800' : '#f44336';
          ctx.fillRect(t.gx * GRID + 4, t.gy * GRID + GRID - 8, (GRID - 8) * hpPct, 4);
        }
        ctx.strokeStyle = 'rgba(0,0,0,0.2)'; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(t.gx * GRID + 4, t.gy * GRID + GRID / 2); ctx.lineTo(t.gx * GRID + GRID - 4, t.gy * GRID + GRID / 2); ctx.stroke();
        break;
      case 'bigrect':
        const bx = t.gx * GRID + 3, by = t.gy * GRID + 6;
        ctx.fillRect(bx, by, GRID - 6, GRID - 12);
        ctx.strokeRect(bx, by, GRID - 6, GRID - 12);
        ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.5;
        ctx.fillRect(bx + 4, by + 3, 6, 5);
        ctx.fillRect(bx + GRID - 16, by + 3, 6, 5);
        ctx.globalAlpha = 1;
        if (t.cooldown > 0) {
          const pct = t.cooldown / def.rate;
          ctx.fillStyle = 'rgba(0,0,0,0.5)';
          ctx.fillRect(t.gx * GRID, t.gy * GRID, GRID * pct, GRID);
        }
        break;
      case 'diamond':
        ctx.beginPath();
        ctx.moveTo(cx, cy - r); ctx.lineTo(cx + r, cy); ctx.lineTo(cx, cy + r); ctx.lineTo(cx - r, cy);
        ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI * 2); ctx.stroke();
        ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(cx, cy, 1.5, 0, Math.PI * 2); ctx.fill();
        if (def.reveals) {
          ctx.strokeStyle = 'rgba(240,168,48,0.15)'; ctx.lineWidth = 1;
          ctx.beginPath(); ctx.arc(cx, cy, def.range, 0, Math.PI * 2); ctx.stroke();
        }
        break;
    }

    if (t.firing > 0) {
      ctx.fillStyle = 'rgba(255,200,50,' + (t.firing / 8) + ')';
      ctx.beginPath(); ctx.arc(cx, cy, r + 4, 0, Math.PI * 2); ctx.fill();
      t.firing--;
    }
  }

  function drawEnemy(e) {
    const x = e.x, y = e.y;
    const sz = e.isBoss ? 14 : e.isCoyote ? 10 : 7;

    ctx.fillStyle = 'rgba(0,0,0,0.2)';
    ctx.beginPath(); ctx.ellipse(x, y + sz + 2, sz * 0.7, 3, 0, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = e.isBoss ? '#5C0000' : e.isCoyote ? '#8B0000' : '#4a2020';
    ctx.beginPath(); ctx.arc(x, y, sz, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = e.isBoss ? '#800000' : e.isCoyote ? '#a03030' : '#6a3a3a';
    ctx.beginPath(); ctx.arc(x, y - sz - 3, sz * 0.5, 0, Math.PI * 2); ctx.fill();

    if (e.isBoss) {
      // Boss crown indicator
      ctx.fillStyle = '#F0A830';
      ctx.beginPath();
      ctx.moveTo(x - 6, y - sz - 6); ctx.lineTo(x - 4, y - sz - 10);
      ctx.lineTo(x, y - sz - 7); ctx.lineTo(x + 4, y - sz - 10);
      ctx.lineTo(x + 6, y - sz - 6); ctx.closePath(); ctx.fill();
    }

    if (e.inTunnel) {
      ctx.globalAlpha = 0.3 + Math.sin(animFrame * 0.1) * 0.2;
      ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.setLineDash([3, 3]);
      ctx.beginPath(); ctx.arc(x, y, sz + 4, 0, Math.PI * 2); ctx.stroke();
      ctx.setLineDash([]); ctx.globalAlpha = 1;
    }

    if (e.slowTimer > 0) {
      ctx.strokeStyle = 'rgba(100,150,255,0.6)'; ctx.lineWidth = 2;
      ctx.beginPath(); ctx.arc(x, y, sz + 3, 0, Math.PI * 2); ctx.stroke();
    }

    if (e.hp < e.maxHp) {
      const bw = sz * 2.5;
      ctx.fillStyle = '#333'; ctx.fillRect(x - bw / 2, y - sz - 10, bw, 3);
      ctx.fillStyle = '#f44336'; ctx.fillRect(x - bw / 2, y - sz - 10, bw * (e.hp / e.maxHp), 3);
    }
  }

  const var_gold = '#F0A830';

  function drawProjectiles() {
    for (const p of projectiles) {
      ctx.fillStyle = p.color || '#ffcc00';
      ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI * 2); ctx.fill();
    }
  }

  function drawParticles() {
    for (const p of particles) {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
    }
    ctx.globalAlpha = 1;
  }

  // === ENEMIES ===
  function spawnEnemy(hp, speed, isCoyote, usesTunnel, isBoss) {
    const start = path[0];
    enemies.push({
      x: start.x * GRID + GRID / 2,
      y: start.y * GRID + GRID / 2,
      pathIdx: 0,
      speed: speed * (isCoyote ? 0.7 : 1) * (isBoss ? 0.5 : 1),
      hp: isBoss ? hp * 8 : isCoyote ? hp * 3 : hp,
      maxHp: isBoss ? hp * 8 : isCoyote ? hp * 3 : hp,
      isCoyote: isCoyote || isBoss,
      isBoss: !!isBoss,
      inTunnel: usesTunnel,
      tunnelRevealed: false,
      slowTimer: 0,
      reward: isBoss ? 100 : isCoyote ? 30 : 10,
      alive: true
    });
  }

  function updateEnemies() {
    for (const e of enemies) {
      if (!e.alive) continue;

      let spd = e.speed;
      if (e.slowTimer > 0) { spd *= 0.4; e.slowTimer--; }

      const target = path[e.pathIdx + 1];
      if (!target) {
        e.alive = false;
        lives--;
        updateHUD();
        spawnParticles(e.x, e.y, '#ff0000', 5);
        if (lives <= 0) endGame();
        continue;
      }

      // Check if next path tile has a wall — stop and attack it
      const nextPath = path[e.pathIdx + 1];
      if (nextPath) {
        const wallAheadKey = nextPath.x + ',' + nextPath.y;
        const wallAhead = towerGrid[wallAheadKey];
        if (wallAhead && wallAhead.type === 'wall' && wallAhead.alive) {
          // Stop moving and attack the wall
          wallAhead.hp -= 0.03;
          if (wallAhead.hp <= 0) {
            wallAhead.alive = false;
            delete towerGrid[wallAheadKey];
            spawnParticles(wallAhead.gx * GRID + GRID / 2, wallAhead.gy * GRID + GRID / 2, '#c8874a', 8);
          }
          continue; // don't move this frame
        }
      }

      const tx = target.x * GRID + GRID / 2;
      const ty = target.y * GRID + GRID / 2;
      const dx = tx - e.x, dy = ty - e.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < spd * 2) {
        e.pathIdx++;
        e.x = tx; e.y = ty;
      } else {
        e.x += (dx / dist) * spd;
        e.y += (dy / dist) * spd;
      }
    }
    enemies = enemies.filter(e => e.alive);
  }

  // === TOWERS ===
  function updateTowers() {
    for (const key in towerGrid) {
      const t = towerGrid[key];
      if (!t.alive) continue;
      const def = UNIT_DEFS[t.type];
      if (def.range === 0) continue;

      t.cooldown = Math.max(0, t.cooldown - 1);
      if (t.cooldown > 0) continue;

      const cx = t.gx * GRID + GRID / 2;
      const cy = t.gy * GRID + GRID / 2;
      let range = def.range;

      if (def.boost) {
        for (const k2 in towerGrid) {
          const t2 = towerGrid[k2];
          if (t2.type === 'ice' && t2.alive) {
            const d = Math.sqrt((t.gx - t2.gx) ** 2 + (t.gy - t2.gy) ** 2) * GRID;
            if (d < def.range) t2.boosted = true;
          }
        }
      }

      let targets = [];
      for (const e of enemies) {
        if (!e.alive) continue;
        if (e.inTunnel && !e.tunnelRevealed) {
          if (def.reveals) {
            const d = Math.sqrt((cx - e.x) ** 2 + (cy - e.y) ** 2);
            if (d < range) { e.tunnelRevealed = true; e.inTunnel = false; }
          }
          continue;
        }
        const d = Math.sqrt((cx - e.x) ** 2 + (cy - e.y) ** 2);
        if (d < range) targets.push({ e, d });
      }

      if (targets.length === 0) continue;
      targets.sort((a, b) => a.d - b.d);

      let effectiveRate = def.rate;
      if (t.boosted) { effectiveRate = Math.floor(effectiveRate * 0.7); t.boosted = false; }

      t.cooldown = effectiveRate;
      t.firing = 8;

      if (def.aoe) {
        const count = Math.min(targets.length, def.type === 'bus' ? 5 : 3);
        for (let i = 0; i < count; i++) {
          const e = targets[i].e;
          e.hp -= def.dmg;
          if (def.slow) e.slowTimer = 60;
          projectiles.push({ x: cx, y: cy, tx: e.x, ty: e.y, life: 8, color: def.color });
          if (e.hp <= 0) killEnemy(e);
        }
      } else {
        const e = targets[0].e;
        e.hp -= def.dmg;
        if (def.slow) e.slowTimer = 60;
        projectiles.push({ x: cx, y: cy, tx: e.x, ty: e.y, life: 8, color: def.color });
        if (e.hp <= 0) killEnemy(e);
      }
    }
  }

  function killEnemy(e) {
    if (!e.alive) return;
    e.alive = false;
    money += e.reward;
    score += e.reward;
    deportations++;
    spawnParticles(e.x, e.y, COLORS.gold, 6);
    updateHUD();
  }

  // === PROJECTILES & PARTICLES ===
  function updateProjectiles() {
    for (const p of projectiles) {
      const dx = p.tx - p.x, dy = p.ty - p.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < 5 || p.life <= 0) { p.dead = true; continue; }
      const spd = Math.min(dist, 12);
      p.x += (dx / dist) * spd;
      p.y += (dy / dist) * spd;
      p.life--;
    }
    projectiles = projectiles.filter(p => !p.dead);
  }

  function spawnParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x, y,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        life: 1,
        decay: 0.02 + Math.random() * 0.03,
        size: 2 + Math.random() * 3,
        color
      });
    }
  }

  function updateParticles() {
    for (const p of particles) {
      p.x += p.vx; p.y += p.vy;
      p.life -= p.decay;
    }
    particles = particles.filter(p => p.life > 0);
  }

  // === WAVES ===
  function startWave() {
    currentWave++;
    const lvl = currentLevel;
    waveConfig = lvl.waveGen(currentWave, lvl.waves);
    waveEnemiesLeft = waveConfig.count;
    waveSpawnTimer = 0;
    gameState = 'playing';
    updateHUD();
    showBanner('Wave ' + currentWave + ' / ' + lvl.waves);
  }

  function updateWaveSpawning() {
    if (waveEnemiesLeft <= 0) {
      if (enemies.length === 0) {
        // Wave complete
        money += 25 + currentWave * 5;
        score += 50 * currentWave;
        updateHUD();

        if (currentWave >= currentLevel.waves) {
          // Level complete!
          levelComplete();
          return;
        }

        gameState = 'wavepause';
        wavePauseTimer = 120;
        showBanner('Wave ' + currentWave + ' Complete');
      }
      return;
    }
    waveSpawnTimer--;
    if (waveSpawnTimer <= 0) {
      const cfg = waveConfig;
      const isCoyote = Math.random() < cfg.coyoteChance;
      const usesTunnel = Math.random() < cfg.tunnelChance;
      const isBoss = cfg.boss && waveEnemiesLeft === 1;
      spawnEnemy(cfg.enemyHp, cfg.enemySpeed + (Math.random() * 0.3), isCoyote, usesTunnel, isBoss);
      waveEnemiesLeft--;
      waveSpawnTimer = cfg.spawnInterval;
    }
  }

  // === HUD ===
  function updateHUD() {
    document.getElementById('hud-wave').textContent = currentWave + '/' + (currentLevel ? currentLevel.waves : '?');
    document.getElementById('hud-money').textContent = '$' + money;
    document.getElementById('hud-lives').textContent = lives;
    document.getElementById('hud-score').textContent = score;

    document.querySelectorAll('.unit-btn').forEach(btn => {
      const type = btn.dataset.unit;
      if (UNIT_DEFS[type]) btn.classList.toggle('disabled', money < UNIT_DEFS[type].cost);
    });
  }

  function showBanner(text) {
    const el = document.getElementById('wave-banner');
    el.textContent = text;
    gsap.fromTo(el, { opacity: 0, scale: 0.5 }, { opacity: 1, scale: 1, duration: 0.4, ease: 'back.out' });
    gsap.to(el, { opacity: 0, delay: 1.5, duration: 0.5 });
  }

  // === GAME LOOP ===
  function gameLoop() {
    animFrame++;
    if (gameState === 'playing') {
      updateWaveSpawning();
      updateEnemies();
      updateTowers();
      updateProjectiles();
      updateParticles();
    } else if (gameState === 'wavepause') {
      wavePauseTimer--;
      updateParticles();
      if (wavePauseTimer <= 0) startWave();
    }

    drawBackground();
    drawPath();
    if (gameState === 'playing' || gameState === 'wavepause') {
      drawPlacementPreview();
      for (const key in towerGrid) {
        if (towerGrid[key].alive) drawTower(towerGrid[key]);
      }
      for (const e of enemies) if (e.alive) drawEnemy(e);
      drawProjectiles();
      drawParticles();
    }

    requestAnimationFrame(gameLoop);
  }

  // === GAME MANAGEMENT ===
  function startLevel(levelId) {
    currentLevel = LEVELS[levelId - 1];
    currentWave = 0;
    money = currentLevel.money;
    lives = 10;
    score = 0;
    deportations = 0;
    enemies = []; towers = []; projectiles = []; particles = [];
    towerGrid = {};
    selectedUnit = null;
    document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('selected'));
    document.getElementById('hud-top').style.display = 'flex';
    document.getElementById('hud-bottom').style.display = 'flex';
    resize();
    buildPath(levelId * 17 + 3);
    updateHUD();
    hideAllOverlays();
    gameState = 'wavepause';
    wavePauseTimer = 90;
    showBanner(currentLevel.name);
  }

  function calcStars(livesLeft) {
    if (livesLeft >= 8) return 3;
    if (livesLeft >= 4) return 2;
    if (livesLeft >= 1) return 1;
    return 0;
  }

  function levelComplete() {
    gameState = 'complete';
    const stars = calcStars(lives);
    completeLevel(currentLevel.id, stars, score);

    document.getElementById('lc-score').textContent = score;
    document.getElementById('lc-deports').textContent = deportations;
    document.getElementById('lc-lives').textContent = lives;

    // Show/hide next level button
    document.getElementById('btn-nextlevel').style.display = currentLevel.id < 10 ? '' : 'none';

    const starsEl = document.getElementById('complete-stars');
    const starIcons = starsEl.querySelectorAll('i');
    starIcons.forEach(s => s.classList.remove('earned'));

    document.getElementById('complete-overlay').classList.remove('hidden');
    gsap.fromTo('#complete-overlay', { opacity: 0 }, { opacity: 1, duration: 0.4 });

    // Animate stars
    for (let i = 0; i < stars; i++) {
      gsap.fromTo(starIcons[i], { scale: 0 }, {
        scale: 1, duration: 0.4, delay: 0.5 + i * 0.3, ease: 'back.out',
        onStart: () => starIcons[i].classList.add('earned')
      });
    }
  }

  function endGame() {
    gameState = 'gameover';
    document.getElementById('go-score').textContent = score;
    document.getElementById('go-waves').textContent = currentWave;
    document.getElementById('go-deports').textContent = deportations;
    document.getElementById('gameover-overlay').classList.remove('hidden');
    gsap.fromTo('#gameover-overlay', { opacity: 0 }, { opacity: 1, duration: 0.5 });
  }

  function showLevelSelect() {
    gameState = 'menu';
    document.getElementById('hud-top').style.display = 'none';
    document.getElementById('hud-bottom').style.display = 'none';
    resize();
    hideAllOverlays();
    renderLevelGrid();
    document.getElementById('levelselect-overlay').classList.remove('hidden');
    gsap.fromTo('#ls-title', { opacity: 0, y: -20 }, { opacity: 1, y: 0, duration: 0.5, ease: 'power3.out' });
  }

  function renderLevelGrid() {
    progress = loadProgress();
    const grid = document.getElementById('level-grid');
    let totalStars = 0, maxStars = 30;
    let html = '';
    for (const lvl of LEVELS) {
      const lp = getLevelProgress(lvl.id);
      const locked = !lp.unlocked;
      totalStars += lp.stars || 0;
      let starsHtml = '';
      for (let s = 1; s <= 3; s++) {
        starsHtml += '<i class="fas fa-star' + (s <= (lp.stars || 0) ? ' earned' : '') + '"></i>';
      }
      html += '<div class="level-card' + (locked ? ' locked' : '') + '" data-level="' + lvl.id + '">' +
        (locked ? '<div class="lc-lock"><i class="fas fa-lock"></i></div>' : '') +
        '<div class="lc-num">Level ' + lvl.id + '</div>' +
        '<div class="lc-name">' + lvl.name + '</div>' +
        '<div class="lc-info">' + lvl.waves + ' waves — ' + lvl.desc + '</div>' +
        (locked ? '' : '<div class="lc-stars">' + starsHtml + '</div>') +
        (lp.highScore > 0 ? '<div class="lc-highscore">Best: ' + lp.highScore + ' pts</div>' : '') +
        '</div>';
    }
    grid.innerHTML = html;
    document.getElementById('ls-total-stars').innerHTML =
      '<i class="fas fa-star" style="color:var(--gold);margin-right:4px;"></i> ' + totalStars + ' / ' + maxStars + ' Stars';

    grid.querySelectorAll('.level-card:not(.locked)').forEach(card => {
      card.addEventListener('click', () => {
        startLevel(parseInt(card.dataset.level));
      });
    });
  }

  function hideAllOverlays() {
    document.querySelectorAll('.overlay').forEach(o => o.classList.add('hidden'));
  }

  function shareScore(context) {
    const lvlName = currentLevel ? currentLevel.name : 'DEPORT';
    const text = context === 'win'
      ? `I completed "${lvlName}" in DEPORT with ${calcStars(lives)} stars and ${score} points! ${deportations} deportations. Play at ${location.href}`
      : `I scored ${score} points on "${lvlName}" in DEPORT! Survived ${currentWave} waves with ${deportations} deportations. Play at ${location.href}`;
    if (navigator.share) {
      navigator.share({ title: 'DEPORT — Tower Defense', text });
    } else {
      navigator.clipboard.writeText(text).then(() => showBanner('Copied to clipboard!'));
    }
  }

  // === INPUT ===
  function getGridPos(e) {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX || e.touches[0].clientX) - rect.left;
    const y = (e.clientY || e.touches[0].clientY) - rect.top;
    return { gx: Math.floor(x / GRID), gy: Math.floor(y / GRID) };
  }

  canvas.addEventListener('mousemove', (e) => {
    const { gx, gy } = getGridPos(e);
    mouseGX = gx; mouseGY = gy;
  });

  canvas.addEventListener('mouseleave', () => { mouseGX = -1; mouseGY = -1; });

  canvas.addEventListener('click', handlePlace);
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const { gx, gy } = getGridPos(e);
    mouseGX = gx; mouseGY = gy;
    handlePlace(e);
  }, { passive: false });

  function handlePlace(e) {
    if (gameState !== 'playing' && gameState !== 'wavepause') return;
    if (!selectedUnit) return;

    const gx = mouseGX, gy = mouseGY;
    if (gx < 0 || gy < 0 || gx >= cols || gy >= rows) return;

    const key = gx + ',' + gy;
    const def = UNIT_DEFS[selectedUnit];
    const onPath = pathSet.has(key);
    const occupied = towerGrid[key];

    if (occupied) return;
    if (def.blocks && !onPath) return;
    if (!def.blocks && onPath) return;
    if (money < def.cost) return;

    money -= def.cost;
    towerGrid[key] = {
      type: selectedUnit, gx, gy, alive: true,
      cooldown: 0, firing: 0, boosted: false,
      hp: def.hp || 0
    };
    updateHUD();
    spawnParticles(gx * GRID + GRID / 2, gy * GRID + GRID / 2, '#ffffff', 4);
  }

  // Unit selection
  document.querySelectorAll('.unit-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const type = btn.dataset.unit;
      if (selectedUnit === type) {
        selectedUnit = null;
        btn.classList.remove('selected');
      } else {
        document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('selected'));
        selectedUnit = type;
        btn.classList.add('selected');
      }
    });
  });

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    const map = { '1': 'ice', '2': 'wall', '3': 'drone', '4': 'tower', '5': 'bus' };
    if (map[e.key]) {
      selectedUnit = map[e.key];
      document.querySelectorAll('.unit-btn').forEach(b => b.classList.toggle('selected', b.dataset.unit === selectedUnit));
    }
    if (e.key === 'Escape') {
      selectedUnit = null;
      document.querySelectorAll('.unit-btn').forEach(b => b.classList.remove('selected'));
    }
  });

  // Menu buttons
  document.getElementById('btn-howto').addEventListener('click', () => {
    hideAllOverlays();
    document.getElementById('howto-overlay').classList.remove('hidden');
    gsap.fromTo('#howto-overlay', { opacity: 0 }, { opacity: 1, duration: 0.3 });
  });
  document.getElementById('btn-howto-back').addEventListener('click', showLevelSelect);

  // Game over buttons
  document.getElementById('btn-retry').addEventListener('click', () => startLevel(currentLevel.id));
  document.getElementById('btn-levelselect-lose').addEventListener('click', showLevelSelect);
  document.getElementById('btn-share-lose').addEventListener('click', () => shareScore('lose'));

  // Level complete buttons
  document.getElementById('btn-nextlevel').addEventListener('click', () => startLevel(currentLevel.id + 1));
  document.getElementById('btn-replay-win').addEventListener('click', () => startLevel(currentLevel.id));
  document.getElementById('btn-levelselect-win').addEventListener('click', showLevelSelect);
  document.getElementById('btn-share-win').addEventListener('click', () => shareScore('win'));

  // === INIT ===
  window.addEventListener('resize', resize);
  resize();
  showLevelSelect();
  gameLoop();

})();
</script>
</body>
</html>
