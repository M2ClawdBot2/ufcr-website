<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>DEPORT — UFCR Games</title>
  <link rel="icon" href="../assets/images/shield-logo.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&family=Oswald:wght@500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
  <style>
    :root{--orange:#FA4616;--gold:#F0A830;--navy:#001845;--dark:#0A0E1A;--red:#D32F2F;--green:#43A047;--font-body:'Inter',sans-serif;--font-heading:'Oswald',sans-serif}
    *,*::before,*::after{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%;overflow:hidden;font-family:var(--font-body);background:#111;color:#fff;-webkit-tap-highlight-color:transparent;user-select:none;touch-action:none}
    .nav{position:fixed;top:0;left:0;right:0;z-index:100;height:44px;background:rgba(0,24,69,.95);backdrop-filter:blur(20px);border-bottom:1px solid rgba(255,255,255,.06);display:flex;align-items:center;justify-content:space-between;padding:0 12px}
    .nav-logo{display:flex;align-items:center;gap:6px;text-decoration:none;color:#fff}
    .nav-logo img{height:26px;border-radius:3px;background:#fff;padding:1px}
    .nav-logo span{font-family:var(--font-heading);font-size:.95rem;font-weight:700;letter-spacing:.08em}
    .nav-back{font-size:.65rem;color:rgba(255,255,255,.5);text-decoration:none;letter-spacing:.1em;text-transform:uppercase;font-weight:600}
    .hud{position:fixed;top:44px;left:0;right:0;z-index:90;display:flex;justify-content:space-between;padding:6px 16px;background:rgba(0,24,69,.7);backdrop-filter:blur(10px);border-bottom:1px solid rgba(255,255,255,.05)}
    .hud-item{text-align:center;flex:1}
    .hud-label{font-size:.5rem;text-transform:uppercase;letter-spacing:.15em;color:rgba(255,255,255,.3)}
    .hud-value{font-family:var(--font-heading);font-size:1.1rem;font-weight:700}
    .hud-value.score{color:var(--gold)}.hud-value.wave{color:var(--green)}.hud-value.active{color:var(--orange)}
    canvas{position:fixed;top:0;left:0;width:100%;height:100%;display:block;cursor:none}
    .screen-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(5,8,18,.94);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:200;padding:24px;text-align:center}
    .screen-overlay.hidden{display:none}
    .screen-title{font-family:var(--font-heading);font-size:clamp(2.2rem,8vw,4rem);font-weight:700;text-transform:uppercase;letter-spacing:.04em;margin-bottom:6px}
    .screen-sub{font-size:.9rem;color:rgba(255,255,255,.45);margin-bottom:24px;max-width:360px;line-height:1.6}
    .screen-stats{margin-bottom:24px;min-width:220px}
    .stat-row{display:flex;justify-content:space-between;font-size:.9rem;padding:5px 0;border-bottom:1px solid rgba(255,255,255,.05)}
    .stat-label{color:rgba(255,255,255,.35)}.stat-val{font-weight:700;color:var(--gold)}
    .level-badge{font-family:var(--font-heading);font-size:.65rem;font-weight:600;letter-spacing:.2em;text-transform:uppercase;color:var(--gold);margin-bottom:6px}
    .btn{font-family:var(--font-heading);font-size:1rem;font-weight:600;letter-spacing:.12em;text-transform:uppercase;background:var(--orange);color:#fff;border:none;padding:12px 32px;cursor:pointer;transition:all .3s}
    .btn:hover{background:#e03a0e;transform:translateY(-2px)}
    .share-btns{display:flex;gap:10px;margin-top:12px}
    .share-btn{font-family:var(--font-heading);font-size:.65rem;font-weight:600;letter-spacing:.1em;text-transform:uppercase;padding:8px 14px;border:1px solid rgba(255,255,255,.12);background:transparent;color:#fff;cursor:pointer;display:flex;align-items:center;gap:5px;transition:all .3s}
    .share-btn:hover{background:rgba(255,255,255,.06)}
    .how-to{max-width:340px;margin-bottom:20px;text-align:left}
    .how-to li{font-size:.82rem;color:rgba(255,255,255,.5);margin-bottom:5px;line-height:1.5;list-style:none;padding-left:18px;position:relative}
    .how-to li::before{content:'';position:absolute;left:0;top:7px;width:6px;height:6px;background:var(--orange);border-radius:50%}
  </style>
</head>
<body>

<nav class="nav">
  <a href="../" class="nav-logo"><img src="../assets/images/shield-logo.png" alt="UFCR"><span>UFCR</span></a>
  <a href="../games/" class="nav-back"><i class="fas fa-arrow-left"></i> Games</a>
</nav>

<div class="hud" id="hud" style="display:none">
  <div class="hud-item"><div class="hud-label">Caught</div><div class="hud-value score" id="hudScore">0</div></div>
  <div class="hud-item"><div class="hud-label">Wave</div><div class="hud-value wave" id="hudWave">1</div></div>
  <div class="hud-item"><div class="hud-label">Climbing</div><div class="hud-value active" id="hudActive">0</div></div>
</div>

<div class="screen-overlay" id="startScreen">
  <div class="level-badge">UFCR GAMES</div>
  <div class="screen-title" style="color:var(--orange)">DEPORT</div>
  <p class="screen-sub">Patrol the border from your ICE helicopter. Shine your spotlight on illegals climbing the wall and hold it until the ICE truck picks them up. If even one gets over — game over.</p>
  <ul class="how-to">
    <li>Move your helicopter with mouse or finger</li>
    <li>Your spotlight shines below the chopper</li>
    <li>Illegals approach the wall and start climbing — you have 10 seconds</li>
    <li>Spotlight them and <strong>hold the light for 3 seconds</strong> until the ICE truck grabs them</li>
    <li>If you move the light away, the truck turns back</li>
    <li>One illegal over the wall = game over</li>
  </ul>
  <button class="btn" id="startBtn">Start Patrol</button>
</div>

<div class="screen-overlay hidden" id="gameOverScreen">
  <div class="level-badge">BORDER BREACHED</div>
  <div class="screen-title" id="goTitle" style="color:var(--red)">Game Over</div>
  <p class="screen-sub" id="goSub"></p>
  <div class="screen-stats" id="goStats"></div>
  <button class="btn" id="restartBtn">Try Again</button>
  <div class="share-btns">
    <button class="share-btn" id="shareBtn"><i class="fab fa-x-twitter"></i> Share</button>
    <button class="share-btn" id="copyBtn"><i class="fas fa-copy"></i> Copy</button>
  </div>
</div>

<canvas id="game"></canvas>

<script>
const CV = document.getElementById('game');
const cx = CV.getContext('2d');

let W, H, dpr;
const ZOOM = 1.25;
function resize() {
  dpr = window.devicePixelRatio || 1;
  W = window.innerWidth; H = window.innerHeight;
  CV.width = W * dpr; CV.height = H * dpr;
  CV.style.width = W + 'px'; CV.style.height = H + 'px';
  cx.setTransform(dpr * ZOOM, 0, 0, dpr * ZOOM, 0, 0);
  W = W / ZOOM; H = H / ZOOM;
  // Recalc zones
  NAV_H = (44 + 36) / ZOOM;
  WALL_Y = NAV_H + 32;
  WALL_H = 26;
  GROUND_TOP = WALL_Y + WALL_H + 10;
  SPAWN_Y = H + 20;
  CITY_Y = WALL_Y - 20; // above wall = city
}

let NAV_H, WALL_Y, WALL_H, GROUND_TOP, SPAWN_Y, CITY_Y;
resize();
window.addEventListener('resize', resize);

// ─── COLORS ───
const COL = {
  night: '#0d1520',
  ground: '#2a2218',
  groundLight: '#3a3025',
  wall: '#888',
  wallLight: '#aaa',
  wallDark: '#666',
  road: '#333',
  spotlight: 'rgba(255,255,200,',
  orange: '#FA4616',
  gold: '#F0A830',
  red: '#D32F2F',
  green: '#43A047',
  truckBlue: '#2255aa',
};

// ─── STATE ───
let gameRunning = false;
let score = 0, wave = 1, lastTime = 0;
let heliX, heliY, targetX, targetY;
let illegals = [], trucks = [], effects = [], stars = [], tireTracks = [];
let spawnTimer = 0, waveCount = 0;
let heliAngle = 0, heliBladeAngle = 0;

// Stars
for (let i = 0; i < 80; i++) {
  stars.push({ x: Math.random(), y: Math.random() * 0.35, brightness: 0.2 + Math.random() * 0.6, twinkle: Math.random() * Math.PI * 2 });
}

// ─── LEVEL CONFIG ───
function getWaveConfig(w) {
  return {
    spawnInterval: Math.max(1.5, 5 - (w-1) * 0.4),
    climbTime: 10, // always 10s to climb
    truckSpeed: 320 + w * 30,
    truckArriveTime: 3, // 3 seconds spotlight to deport
    maxSimultaneous: Math.min(6, 1 + Math.floor(w * 0.6)),
  };
}

// ─── ILLEGAL ───
function spawnIllegal() {
  const x = 40 + Math.random() * (W - 80);
  illegals.push({
    x, y: SPAWN_Y,
    // Walk to wall then climb
    state: 'walking', // walking -> climbing -> over
    walkSpeed: 40 + Math.random() * 20,
    climbProgress: 0, // 0 to 1
    climbTime: 10,
    spotted: false,
    spotTime: 0, // how long spotlight held
    truckArriveTime: getWaveConfig(wave).truckArriveTime,
    caught: false,
    catchAnim: 0,
    overAnim: 0,
    // Appearance (low poly cute)
    bodyHue: 20 + Math.random() * 30,
    shirtHue: Math.random() * 360,
    hatType: Math.floor(Math.random() * 3),
    size: 8 + Math.random() * 2,
    id: Math.random(),
  });
}

// ─── TRUCK ───
function dispatchTruck(target) {
  // Already has a truck?
  if (trucks.some(t => t.targetId === target.id && t.active)) return;
  const startX = -40;
  const dist = Math.abs(target.x - startX) + 20; // distance to cover
  const timeRemaining = target.truckArriveTime - target.spotTime; // seconds left on ring
  const speed = dist / Math.max(0.1, timeRemaining); // arrive exactly when ring closes
  trucks.push({
    x: startX,
    y: target.y + 10,
    targetId: target.id,
    targetX: target.x,
    speed: speed,
    active: true,
    returning: false,
    arrived: false,
    loadAnim: 0,
    hasPassenger: false,
  });
}

// ─── EFFECTS ───
function addEffect(x, y, text, color) {
  effects.push({ x, y, text, color, life: 1 });
}

// ─── INPUT ───
heliX = W / 2; heliY = H / 2;
targetX = heliX; targetY = heliY;

function setTarget(px, py) {
  targetX = px / ZOOM;
  targetY = Math.max(NAV_H + 16, py / ZOOM);
}

CV.addEventListener('mousemove', e => setTarget(e.clientX, e.clientY));
CV.addEventListener('touchmove', e => { e.preventDefault(); setTarget(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });
CV.addEventListener('touchstart', e => { e.preventDefault(); setTarget(e.touches[0].clientX, e.touches[0].clientY); }, { passive: false });

// ─── HUD ───
function updateHUD() {
  document.getElementById('hudScore').textContent = score;
  document.getElementById('hudWave').textContent = wave;
  const climbing = illegals.filter(i => !i.caught && i.state !== 'over').length;
  document.getElementById('hudActive').textContent = climbing;
}

// ─── DRAW HELPERS ───
function drawLowPolyPerson(x, y, size, hue, shirtHue, hatType, climbing, climbProg) {
  const s = size;
  let bodyY = y;
  let legSpread = 0;

  if (climbing) {
    // Person facing wall, climbing up
    const wallBase = WALL_Y + WALL_H;
    bodyY = wallBase - climbProg * (WALL_H + s * 2);
    legSpread = Math.sin(climbProg * 20) * 2;
  }

  // Shadow (only on ground)
  if (!climbing) {
    cx.fillStyle = 'rgba(0,0,0,0.3)';
    cx.beginPath();
    cx.ellipse(x, bodyY + s * 1.5, s * 0.8, s * 0.2, 0, 0, Math.PI * 2);
    cx.fill();
  }

  // Legs
  cx.strokeStyle = `hsl(220,15%,30%)`;
  cx.lineWidth = 2.5;
  cx.lineCap = 'round';
  if (climbing) {
    cx.beginPath(); cx.moveTo(x - 2, bodyY + s * 0.5); cx.lineTo(x - 3 - legSpread, bodyY + s * 1.5); cx.stroke();
    cx.beginPath(); cx.moveTo(x + 2, bodyY + s * 0.5); cx.lineTo(x + 3 + legSpread, bodyY + s * 1.5); cx.stroke();
  } else {
    const walk = Math.sin(Date.now() * 0.008 + x) * 2;
    cx.beginPath(); cx.moveTo(x - 2, bodyY + s * 0.4); cx.lineTo(x - 2 + walk, bodyY + s * 1.4); cx.stroke();
    cx.beginPath(); cx.moveTo(x + 2, bodyY + s * 0.4); cx.lineTo(x + 2 - walk, bodyY + s * 1.4); cx.stroke();
  }

  // Body (low poly = simple rectangle with slight taper)
  cx.fillStyle = `hsl(${shirtHue},25%,35%)`;
  cx.beginPath();
  cx.moveTo(x - s * 0.5, bodyY - s * 0.3);
  cx.lineTo(x + s * 0.5, bodyY - s * 0.3);
  cx.lineTo(x + s * 0.4, bodyY + s * 0.5);
  cx.lineTo(x - s * 0.4, bodyY + s * 0.5);
  cx.closePath();
  cx.fill();

  // Arms
  cx.strokeStyle = `hsl(${hue},35%,55%)`;
  cx.lineWidth = 2;
  if (climbing) {
    // Arms reaching up
    cx.beginPath(); cx.moveTo(x - s * 0.5, bodyY - s * 0.1); cx.lineTo(x - s * 0.7, bodyY - s * 1); cx.stroke();
    cx.beginPath(); cx.moveTo(x + s * 0.5, bodyY - s * 0.1); cx.lineTo(x + s * 0.7, bodyY - s * 1.2); cx.stroke();
  } else {
    const armSwing = Math.sin(Date.now() * 0.008 + x) * s * 0.3;
    cx.beginPath(); cx.moveTo(x - s * 0.5, bodyY - s * 0.1); cx.lineTo(x - s * 0.9 - armSwing, bodyY + s * 0.5); cx.stroke();
    cx.beginPath(); cx.moveTo(x + s * 0.5, bodyY - s * 0.1); cx.lineTo(x + s * 0.9 + armSwing, bodyY + s * 0.5); cx.stroke();
  }

  // Head
  cx.fillStyle = `hsl(${hue},35%,55%)`;
  cx.beginPath();
  cx.arc(x, bodyY - s * 0.7, s * 0.4, 0, Math.PI * 2);
  cx.fill();

  // Hat
  if (hatType === 0) {
    // Baseball cap
    cx.fillStyle = `hsl(${shirtHue + 40},20%,25%)`;
    cx.beginPath();
    cx.ellipse(x, bodyY - s * 0.95, s * 0.5, s * 0.15, 0, 0, Math.PI * 2);
    cx.fill();
    cx.fillRect(x - s * 0.3, bodyY - s * 1.15, s * 0.6, s * 0.3);
  } else if (hatType === 1) {
    // Beanie
    cx.fillStyle = `hsl(0,0%,20%)`;
    cx.beginPath();
    cx.arc(x, bodyY - s * 0.9, s * 0.38, Math.PI, 0);
    cx.fill();
  }
  // hatType 2 = no hat

  return bodyY;
}

function drawHelicopter(x, y) {
  const s = 18;
  // Body shadow
  cx.fillStyle = 'rgba(0,0,0,0.15)';
  cx.beginPath();
  cx.ellipse(x + 3, y + 3, s * 1.2, s * 0.5, heliAngle * 0.1, 0, Math.PI * 2);
  cx.fill();

  // Tail boom
  cx.strokeStyle = '#444';
  cx.lineWidth = 3;
  cx.beginPath();
  cx.moveTo(x, y);
  cx.lineTo(x - s * 1.8, y + s * 0.2);
  cx.stroke();

  // Tail rotor housing
  cx.fillStyle = '#3a3a3a';
  cx.fillRect(x - s * 2, y - s * 0.3, s * 0.4, s * 0.6);

  // Main body
  const bg = cx.createLinearGradient(x - s * 0.6, y - s * 0.5, x + s * 0.6, y + s * 0.5);
  bg.addColorStop(0, '#4a4a4a');
  bg.addColorStop(0.5, '#5a5a5a');
  bg.addColorStop(1, '#404040');
  cx.fillStyle = bg;
  cx.beginPath();
  cx.ellipse(x, y, s * 1, s * 0.55, 0, 0, Math.PI * 2);
  cx.fill();

  // Windshield
  cx.fillStyle = 'rgba(100,180,255,0.3)';
  cx.beginPath();
  cx.ellipse(x + s * 0.3, y - s * 0.05, s * 0.45, s * 0.3, 0.2, 0, Math.PI * 2);
  cx.fill();

  // ICE marking
  cx.fillStyle = 'rgba(255,255,255,0.6)';
  cx.font = `700 ${s * 0.4}px Oswald, sans-serif`;
  cx.textAlign = 'center';
  cx.fillText('ICE', x - s * 0.2, y + s * 0.15);

  // Skids
  cx.strokeStyle = '#555';
  cx.lineWidth = 1.5;
  cx.beginPath(); cx.moveTo(x - s * 0.6, y + s * 0.55); cx.lineTo(x - s * 0.6, y + s * 0.8); cx.lineTo(x + s * 0.6, y + s * 0.8); cx.lineTo(x + s * 0.6, y + s * 0.55); cx.stroke();

  // Main rotor (spinning)
  heliBladeAngle += 0.15;
  cx.strokeStyle = 'rgba(200,200,200,0.5)';
  cx.lineWidth = 2;
  for (let i = 0; i < 4; i++) {
    const a = heliBladeAngle + (Math.PI / 2) * i;
    cx.beginPath();
    cx.moveTo(x, y);
    cx.lineTo(x + Math.cos(a) * s * 2.2, y + Math.sin(a) * s * 0.6);
    cx.stroke();
  }

  // Rotor disc (motion blur)
  cx.fillStyle = 'rgba(200,200,200,0.06)';
  cx.beginPath();
  cx.ellipse(x, y, s * 2.2, s * 0.6, 0, 0, Math.PI * 2);
  cx.fill();

  // Rotor hub
  cx.fillStyle = '#666';
  cx.beginPath();
  cx.arc(x, y, 3, 0, Math.PI * 2);
  cx.fill();
}

function drawTruck(t) {
  const s = 12;

  // Dust cloud behind truck when moving
  if (!t.arrived || t.returning) {
    const dustDir = t.returning ? 1 : -1;
    for (let i = 0; i < 3; i++) {
      const dx = dustDir * (10 + i * 8 + Math.random() * 6);
      const dy = (Math.random() - 0.5) * 8;
      const r = 4 + Math.random() * 5;
      cx.fillStyle = `rgba(160,140,100,${0.12 - i * 0.03})`;
      cx.beginPath();
      cx.arc(t.x + dx * (t.returning ? -1 : 1) - s * (t.returning ? -1 : 1), t.y + s * 0.2 + dy, r, 0, Math.PI * 2);
      cx.fill();
    }
  }

  // Determine facing direction: +1 = facing right, -1 = facing left
  const dir = t.returning ? -1 : 1;

  cx.save();
  cx.translate(t.x, t.y);
  cx.scale(dir, 1);
  // Now draw truck centered at (0, 0), always facing right in local space

  // Shadow
  cx.fillStyle = 'rgba(0,0,0,0.2)';
  cx.fillRect(-s * 1.2 + 2, s * 0.4 + 2, s * 2.4, s * 0.3);

  // Truck body
  cx.fillStyle = '#e8e8e8';
  cx.beginPath();
  cx.roundRect(-s * 1.2, -s * 0.6, s * 2.4, s * 1, 2);
  cx.fill();

  // Cab (front of truck = right side)
  cx.fillStyle = COL.truckBlue;
  cx.beginPath();
  cx.roundRect(s * 0.5, -s * 0.8, s * 0.8, s * 1.2, [2, 2, 0, 0]);
  cx.fill();

  // Windshield
  cx.fillStyle = 'rgba(150,200,255,0.4)';
  cx.fillRect(s * 0.6, -s * 0.6, s * 0.55, s * 0.4);

  // ICE text on side (flip text back so it reads correctly)
  cx.save();
  cx.scale(dir, 1); // undo the parent flip for text
  cx.fillStyle = COL.truckBlue;
  cx.font = `700 ${s * 0.55}px Oswald, sans-serif`;
  cx.textAlign = 'center';
  cx.fillText('ICE', -s * 0.2 * dir, s * 0.15);
  cx.restore();

  // Wheels
  cx.fillStyle = '#222';
  cx.beginPath(); cx.arc(-s * 0.7, s * 0.45, s * 0.22, 0, Math.PI * 2); cx.fill();
  cx.beginPath(); cx.arc(s * 0.8, s * 0.45, s * 0.22, 0, Math.PI * 2); cx.fill();

  // Flashing lights
  if (Math.sin(Date.now() * 0.01) > 0) {
    cx.fillStyle = 'rgba(255,50,50,0.6)';
    cx.beginPath(); cx.arc(s * 0.7, -s * 0.8, 3, 0, Math.PI * 2); cx.fill();
  } else {
    cx.fillStyle = 'rgba(50,100,255,0.6)';
    cx.beginPath(); cx.arc(s * 0.9, -s * 0.8, 3, 0, Math.PI * 2); cx.fill();
  }

  cx.restore();
}

function drawWall() {
  // Wall shadow
  cx.fillStyle = 'rgba(0,0,0,0.3)';
  cx.fillRect(0, WALL_Y + WALL_H, W, 8);

  // Main wall body
  const wg = cx.createLinearGradient(0, WALL_Y, 0, WALL_Y + WALL_H);
  wg.addColorStop(0, '#b0b0b0');
  wg.addColorStop(0.3, '#c8c8c8');
  wg.addColorStop(0.7, '#a0a0a0');
  wg.addColorStop(1, '#888');
  cx.fillStyle = wg;
  cx.fillRect(0, WALL_Y, W, WALL_H);

  // Steel slat pattern
  cx.strokeStyle = 'rgba(0,0,0,0.08)';
  cx.lineWidth = 1;
  for (let x = 8; x < W; x += 16) {
    cx.beginPath(); cx.moveTo(x, WALL_Y); cx.lineTo(x, WALL_Y + WALL_H); cx.stroke();
  }

  // Horizontal rails
  cx.strokeStyle = 'rgba(0,0,0,0.1)';
  cx.lineWidth = 1.5;
  cx.beginPath(); cx.moveTo(0, WALL_Y + WALL_H * 0.33); cx.lineTo(W, WALL_Y + WALL_H * 0.33); cx.stroke();
  cx.beginPath(); cx.moveTo(0, WALL_Y + WALL_H * 0.66); cx.lineTo(W, WALL_Y + WALL_H * 0.66); cx.stroke();

  // Top razor wire
  cx.strokeStyle = 'rgba(180,180,180,0.5)';
  cx.lineWidth = 1;
  cx.beginPath();
  for (let x = 0; x < W; x += 4) {
    const yy = WALL_Y - 2 + Math.sin(x * 0.4) * 2.5;
    x === 0 ? cx.moveTo(x, yy) : cx.lineTo(x, yy);
  }
  cx.stroke();

  // Coils
  for (let x = 10; x < W; x += 20) {
    cx.strokeStyle = 'rgba(160,160,160,0.3)';
    cx.beginPath();
    cx.ellipse(x, WALL_Y - 3, 8, 3, 0, 0, Math.PI * 2);
    cx.stroke();
  }

  // Wall top highlight
  cx.fillStyle = 'rgba(255,255,255,0.08)';
  cx.fillRect(0, WALL_Y, W, 2);
}

// ─── SPOTLIGHT ───
function drawSpotlight(sx, sy) {
  // Main cone
  const r = 50;
  const g = cx.createRadialGradient(sx, sy, 0, sx, sy, r);
  g.addColorStop(0, 'rgba(255,255,210,0.18)');
  g.addColorStop(0.5, 'rgba(255,255,200,0.08)');
  g.addColorStop(1, 'rgba(255,255,200,0)');
  cx.fillStyle = g;
  cx.beginPath();
  cx.arc(sx, sy, r, 0, Math.PI * 2);
  cx.fill();

  // Hard circle edge
  cx.strokeStyle = 'rgba(255,255,200,0.1)';
  cx.lineWidth = 1;
  cx.beginPath();
  cx.arc(sx, sy, r * 0.7, 0, Math.PI * 2);
  cx.stroke();

  // Beam line from heli to ground
  cx.strokeStyle = 'rgba(255,255,200,0.04)';
  cx.lineWidth = r * 0.3;
  cx.beginPath();
  cx.moveTo(heliX, heliY);
  cx.lineTo(sx, sy);
  cx.stroke();
}

function isSpotlit(ix, iy) {
  // Spotlight position = slightly below helicopter
  const sx = heliX, sy = heliY + 50;
  const dx = ix - sx, dy = iy - sy;
  return Math.sqrt(dx*dx + dy*dy) < 45;
}

// ─── MAIN DRAW ───
function draw() {
  // Night sky
  cx.fillStyle = COL.night;
  cx.fillRect(0, 0, W, H);

  // Stars
  stars.forEach(s => {
    const sy = s.y * (WALL_Y - 20);
    const twinkle = Math.sin(Date.now() * 0.002 + s.twinkle) * 0.3 + 0.7;
    cx.fillStyle = `rgba(255,255,255,${s.brightness * twinkle * 0.5})`;
    cx.beginPath();
    cx.arc(s.x * W, sy, 1, 0, Math.PI * 2);
    cx.fill();
  });

  // City skyline (above wall, background)
  cx.fillStyle = '#151b28';
  const bldgs = [
    [0.05, 0.6], [0.1, 0.8], [0.18, 0.5], [0.22, 0.9], [0.3, 0.4], [0.35, 0.7],
    [0.42, 1.0], [0.48, 0.6], [0.55, 0.8], [0.6, 0.5], [0.68, 0.9], [0.73, 0.7],
    [0.8, 0.6], [0.85, 1.0], [0.92, 0.5], [0.97, 0.7],
  ];
  bldgs.forEach(([bx, bh]) => {
    const x = bx * W;
    const h = bh * 30;
    const w = 20 + bh * 15;
    cx.fillRect(x - w/2, WALL_Y - h - 5, w, h + 5);
    // Windows
    cx.fillStyle = 'rgba(200,180,100,0.15)';
    for (let wy = WALL_Y - h; wy < WALL_Y - 5; wy += 6) {
      for (let wx = x - w/2 + 3; wx < x + w/2 - 3; wx += 6) {
        if (Math.random() > 0.3) cx.fillRect(wx, wy, 3, 3);
      }
    }
    cx.fillStyle = '#151b28';
  });

  // Ground (desert south of wall)
  const gg = cx.createLinearGradient(0, GROUND_TOP, 0, H);
  gg.addColorStop(0, '#2a2015');
  gg.addColorStop(0.5, '#251c12');
  gg.addColorStop(1, '#1a1510');
  cx.fillStyle = gg;
  cx.fillRect(0, GROUND_TOP, W, H - GROUND_TOP);

  // Ground texture
  cx.fillStyle = 'rgba(60,45,30,0.2)';
  for (let i = 0; i < 50; i++) {
    const rx = ((i * 73 + 11) % W);
    const ry = GROUND_TOP + ((i * 47 + 23) % (H - GROUND_TOP));
    cx.beginPath();
    cx.ellipse(rx, ry, 2 + (i%3), 1, 0, 0, Math.PI * 2);
    cx.fill();
  }

  // Dirt road
  cx.fillStyle = 'rgba(50,40,28,0.4)';
  cx.fillRect(0, H - 40, W, 20);
  cx.strokeStyle = 'rgba(80,65,45,0.2)';
  cx.setLineDash([12, 8]);
  cx.beginPath(); cx.moveTo(0, H - 30); cx.lineTo(W, H - 30); cx.stroke();
  cx.setLineDash([]);

  // Tire tracks
  tireTracks.forEach(tt => {
    const a = Math.min(1, tt.life) * 0.25;
    cx.fillStyle = `rgba(20,15,8,${a})`;
    cx.fillRect(tt.x - tt.w/2, tt.y - 1, tt.w, 2);
    cx.fillRect(tt.x - tt.w/2, tt.y + 3, tt.w, 2);
  });

  // Wall
  drawWall();

  // Spotlight on ground
  const spotGX = heliX, spotGY = heliY + 50;
  drawSpotlight(spotGX, spotGY);

  // Illegals
  illegals.forEach(il => {
    if (il.caught) {
      // Caught flash
      if (il.catchAnim < 1) {
        cx.fillStyle = `rgba(67,160,71,${1 - il.catchAnim})`;
        cx.beginPath();
        cx.arc(il.x, il.drawY || il.y, 15, 0, Math.PI * 2);
        cx.fill();
      }
      return;
    }

    let drawY;
    if (il.state === 'walking') {
      drawY = il.y;
      drawLowPolyPerson(il.x, drawY, il.size, il.bodyHue, il.shirtHue, il.hatType, false, 0);
    } else if (il.state === 'climbing') {
      drawLowPolyPerson(il.x, il.y, il.size, il.bodyHue, il.shirtHue, il.hatType, true, il.climbProgress);
      drawY = (WALL_Y + WALL_H) - il.climbProgress * (WALL_H + il.size * 2);

      // Climb progress ring
      cx.strokeStyle = il.spotted ? 'rgba(250,70,22,0.5)' : 'rgba(255,200,50,0.3)';
      cx.lineWidth = 2;
      cx.beginPath();
      cx.arc(il.x, drawY - il.size * 1.5, il.size + 4, -Math.PI/2, -Math.PI/2 + il.climbProgress * Math.PI * 2);
      cx.stroke();
    } else if (il.state === 'over') {
      // Made it over - animate up into city
      drawY = WALL_Y - 10 - il.overAnim * 30;
      drawLowPolyPerson(il.x, drawY, il.size, il.bodyHue, il.shirtHue, il.hatType, false, 0);
    }

    // Show truck progress ring (any state)
    if (il.spotted && il.spotTime > 0 && !il.caught && drawY) {
      const pct = Math.min(1, il.spotTime / il.truckArriveTime);
      cx.strokeStyle = 'rgba(67,160,71,0.7)';
      cx.lineWidth = 2.5;
      cx.beginPath();
      cx.arc(il.x, drawY - il.size * 1.5, il.size + 7, -Math.PI/2, -Math.PI/2 + pct * Math.PI * 2);
      cx.stroke();
    }

    il.drawY = drawY;
  });

  // Trucks
  trucks.forEach(t => { if (t.active) drawTruck(t); });

  // Effects
  cx.textAlign = 'center';
  effects.forEach(e => {
    cx.globalAlpha = e.life;
    cx.fillStyle = e.color;
    cx.font = `700 ${14}px Oswald, sans-serif`;
    cx.fillText(e.text, e.x, e.y - (1-e.life) * 25);
    cx.globalAlpha = 1;
  });

  // Night overlay (darken everything slightly)
  cx.fillStyle = 'rgba(0,5,15,0.15)';
  cx.fillRect(0, 0, W, H);

  // Helicopter (drawn last, on top)
  drawHelicopter(heliX, heliY);
}

// ─── UPDATE ───
function update(dt) {
  if (!gameRunning) return;

  // Move heli toward target (smooth)
  const dx = targetX - heliX, dy = targetY - heliY;
  heliX += dx * 6 * dt;
  heliY += dy * 6 * dt;
  heliAngle = dx * 0.002;

  const spotX = heliX, spotY = heliY + 50;

  // Spawn
  const cfg = getWaveConfig(wave);
  spawnTimer -= dt;
  const activeCount = illegals.filter(i => !i.caught && i.state !== 'over').length;
  if (spawnTimer <= 0 && activeCount < cfg.maxSimultaneous) {
    spawnIllegal();
    spawnTimer = cfg.spawnInterval * (0.7 + Math.random() * 0.6);
    waveCount++;
    if (waveCount >= 5 + wave * 2) {
      wave++;
      waveCount = 0;
      addEffect(W/2, H/2, 'WAVE ' + wave, COL.gold);
    }
  }

  // Update illegals
  illegals.forEach(il => {
    if (il.caught) {
      il.catchAnim += dt * 2;
      return;
    }

    // Get current visual Y for spotlight check
    let checkY = il.y;

    if (il.state === 'walking') {
      il.y -= il.walkSpeed * dt;
      checkY = il.y;
      if (il.y <= WALL_Y + WALL_H + il.size) {
        il.state = 'climbing';
        il.y = WALL_Y + WALL_H;
      }
    } else if (il.state === 'climbing') {
      il.climbProgress += dt / il.climbTime;
      checkY = (WALL_Y + WALL_H) - il.climbProgress * (WALL_H + il.size * 2);

      if (il.climbProgress >= 1 && !il.caught) {
        il.state = 'over';
        il.overAnim = 0;
      }
    } else if (il.state === 'over') {
      il.overAnim += dt;
      if (il.overAnim > 0.5) {
        endGame();
      }
    }

    // Spotlight check — works in ANY state (walking, climbing, over)
    if (!il.caught && il.state !== 'over') {
      const inSpot = isSpotlit(il.x, checkY);
      if (inSpot) {
        il.spotted = true;
        il.spotTime += dt;
        if (il.spotTime >= il.truckArriveTime) {
          il.caught = true;
          il.catchAnim = 0;
          score++;
          addEffect(il.x, checkY, 'CAUGHT +1', COL.green);
          updateHUD();
        }
      } else {
        if (il.spotted) {
          il.spotTime = Math.max(0, il.spotTime - dt * 2);
          if (il.spotTime <= 0) il.spotted = false;
        }
      }
    }
  });

  // Update trucks (visual only, driving toward spotted illegals)
  trucks.forEach(t => {
    if (!t.active) return;
    const target = illegals.find(i => i.id === t.targetId);
    if (!target || target.caught || !target.spotted) {
      t.returning = true;
    }
    const prevX = t.x;
    if (t.returning) {
      t.x -= 400 * dt;
      if (t.x < -50) t.active = false;
    } else {
      // Dynamically recalc speed so truck arrives exactly when ring closes
      if (target) {
        const distLeft = Math.abs(t.targetX - 20 - t.x);
        const timeLeft = target.truckArriveTime - target.spotTime;
        if (timeLeft > 0.05 && distLeft > 1) {
          t.speed = distLeft / timeLeft;
        }
        t.targetX = target.x; // track target position
        t.y = (target.drawY || target.y) + 10; // track target Y
      }
      if (t.x < t.targetX - 20) t.x += t.speed * dt;
      else {
        if (!t.arrived) { t.arrived = true; tireTracks.push({ x: t.x - 15, y: t.y + 8, w: 25, life: 4 }); }
      }
    }
    // Leave tire tracks while moving fast
    if (Math.abs(t.x - prevX) > 2) {
      tireTracks.push({ x: t.x, y: t.y + 8, w: 6, life: 3 + Math.random() });
    }
  });

  // Dispatch trucks for spotted illegals
  illegals.forEach(il => {
    if (il.spotted && !il.caught && il.state !== 'over') {
      if (!trucks.some(t => t.targetId === il.id && t.active && !t.returning)) {
        dispatchTruck(il);
      }
    }
  });

  // Clean up
  illegals = illegals.filter(i => !(i.caught && i.catchAnim > 1.5));
  effects.forEach(e => e.life -= dt * 1.2);
  effects = effects.filter(e => e.life > 0);
  tireTracks.forEach(tt => tt.life -= dt);
  tireTracks = tireTracks.filter(tt => tt.life > 0);

  updateHUD();
}

// ─── LOOP ───
function loop(ts) {
  const dt = Math.min((ts - lastTime) / 1000, 0.05);
  lastTime = ts;
  update(dt);
  draw();
  requestAnimationFrame(loop);
}

// ─── START / END ───
function startGame() {
  score = 0; wave = 1; waveCount = 0;
  illegals = []; trucks = []; effects = []; tireTracks = [];
  spawnTimer = 2;
  heliX = W / 2; heliY = H * 0.5;
  targetX = heliX; targetY = heliY;
  gameRunning = true;
  document.getElementById('hud').style.display = 'flex';
  document.getElementById('startScreen').classList.add('hidden');
  document.getElementById('gameOverScreen').classList.add('hidden');
  updateHUD();
}

function endGame() {
  if (!gameRunning) return;
  gameRunning = false;
  document.getElementById('goSub').textContent = `An illegal made it over the wall. You caught ${score} before the breach.`;
  document.getElementById('goStats').innerHTML = `
    <div class="stat-row"><span class="stat-label">Caught</span><span class="stat-val">${score}</span></div>
    <div class="stat-row"><span class="stat-label">Wave Reached</span><span class="stat-val">${wave}</span></div>`;
  document.getElementById('gameOverScreen').classList.remove('hidden');
}

function shareText() {
  return `DEPORT — ICE Helicopter Patrol\n\nI caught ${score} illegals before the border was breached!\nWave ${wave}\n\nCan you do better?\nufcr.online/deport/`;
}

document.getElementById('startBtn').addEventListener('click', startGame);
document.getElementById('restartBtn').addEventListener('click', startGame);
document.getElementById('shareBtn').addEventListener('click', () => {
  window.open('https://x.com/intent/tweet?text=' + encodeURIComponent(shareText()), '_blank');
});
document.getElementById('copyBtn').addEventListener('click', () => {
  navigator.clipboard.writeText(shareText()).then(() => {
    document.getElementById('copyBtn').innerHTML = '<i class="fas fa-check"></i> Copied!';
    setTimeout(() => { document.getElementById('copyBtn').innerHTML = '<i class="fas fa-copy"></i> Copy'; }, 2000);
  });
});

requestAnimationFrame(loop);
</script>
</body>
</html>
