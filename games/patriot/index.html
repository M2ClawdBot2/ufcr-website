<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>PATRIOT - UFCR</title>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: #0a0f0a; color: white; font-family: 'Segoe UI', sans-serif; overflow: hidden; width: 100vw; height: 100vh; height: 100dvh; }
    #game-container { position: relative; width: 100%; height: 100%; }
    canvas { display: block; touch-action: none; width: 100%; height: 100%; }

    .screen { position: fixed; inset: 0; display: none; flex-direction: column; align-items: center; z-index: 200; overflow-y: auto; overflow-x: hidden; -webkit-overflow-scrolling: touch; }
    .screen.show { display: flex; }

    /* ===== WELCOME ===== */
    #welcome-screen { background: linear-gradient(180deg, #0d1a0d, #0a0f0a); justify-content: center; }
    .welcome-title { font-size: 48px; font-weight: 900; letter-spacing: 6px; color: #c5a44e; text-shadow: 0 2px 8px rgba(160,130,50,0.3); font-family: Georgia, serif; }
    .welcome-sub { font-size: 11px; color: #5a6b5a; letter-spacing: 4px; margin: 4px 0 30px; text-transform: uppercase; }
    .welcome-label { font-size: 12px; color: #7a8a7a; margin-bottom: 8px; letter-spacing: 2px; text-transform: uppercase; }
    #username-input { width: 220px; padding: 12px 16px; font-size: 16px; background: #141e14; border: 1px solid #2a3a2a; border-radius: 2px; color: white; text-align: center; outline: none; }
    #username-input:focus { border-color: #c5a44e; }
    #username-input::placeholder { color: #3a4a3a; }
    .welcome-go { margin-top: 16px; padding: 12px 50px; font-size: 15px; font-weight: bold; background: #c5a44e; color: #0a0f0a; border: none; border-radius: 2px; cursor: pointer; letter-spacing: 2px; text-transform: uppercase; }
    .welcome-go:hover { background: #d4b45e; }

    /* ===== DECK BUILDER ===== */
    #deck-screen { background: #0a0f0a; padding: 16px 10px 60px; justify-content: flex-start; touch-action: pan-y; -webkit-overflow-scrolling: touch; overflow-y: scroll !important; }
    .deck-header { text-align: center; margin-bottom: 6px; }
    .deck-header h2 { font-size: 20px; color: #c5a44e; letter-spacing: 3px; font-family: Georgia, serif; }
    .deck-header p { font-size: 11px; color: #5a6b5a; margin-top: 2px; }
    .deck-username { font-size: 12px; color: #7a8a7a; margin-bottom: 8px; cursor: pointer; }
    .deck-username:hover { color: #c5a44e; }

    #my-deck { display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px; margin: 8px 0 10px; padding: 8px; background: #111a11; border: 1px solid #1e2e1e; border-radius: 2px; width: 100%; }
    #my-deck .deck-slot { height: 52px; background: #0d160d; border: 1px solid #1e2e1e; border-radius: 2px; display: flex; flex-direction: column; align-items: center; justify-content: center; position: relative; cursor: pointer; transition: all 0.12s; }
    #my-deck .deck-slot.filled { border-color: #c5a44e; background: #141e14; }
    #my-deck .deck-slot:hover { border-color: #8b3a3a; }
    .deck-slot .slot-cost { position: absolute; top: 2px; right: 3px; font-size: 8px; font-weight: bold; color: #c5a44e; }
    .deck-slot canvas { width: 24px; height: 24px; }
    .deck-slot .slot-name { font-size: 6px; color: #7a8a7a; text-transform: uppercase; letter-spacing: 0.5px; }
    #deck-count { font-size: 12px; color: #5a6b5a; text-align: center; margin-bottom: 6px; }
    #deck-avg { font-size: 11px; color: #3a4a3a; text-align: center; margin-bottom: 10px; }

    .catalog-section { margin-bottom: 12px; width: 100%; }
    .catalog-section h3 { font-size: 11px; color: #5a6b5a; letter-spacing: 2px; text-transform: uppercase; margin-bottom: 5px; padding-left: 6px; border-left: 2px solid; }
    .cat-swarm h3 { border-color: #4caf50; }
    .cat-offense h3 { border-color: #c62828; }
    .cat-tank h3 { border-color: #8d6e63; }
    .cat-ranged h3 { border-color: #e6a817; }
    .cat-special h3 { border-color: #b71c1c; }

    .catalog-grid { display: grid; grid-template-columns: 1fr; gap: 5px; max-width: 100%; }
    @media (min-width: 480px) { .catalog-grid { grid-template-columns: 1fr 1fr; } }
    .cat-card { background: #111a11; border: 1px solid #1e2e1e; border-radius: 2px; padding: 7px; cursor: pointer; transition: all 0.12s; display: flex; gap: 7px; align-items: center; }
    .cat-card:hover { border-color: #3a4a3a; background: #141e14; }
    .cat-card.in-deck { border-color: #c5a44e; background: #1a2410; opacity: 0.7; }
    .cat-card-icon { flex-shrink: 0; }
    .cat-card-icon canvas { width: 36px; height: 36px; display: block; border-radius: 2px; }
    .cat-card-info { flex: 1; min-width: 0; }
    .cat-card-top { display: flex; align-items: center; gap: 4px; margin-bottom: 2px; }
    .cat-card-name { font-size: 10px; font-weight: bold; color: #ccc; }
    .cat-card-cost { background: #c5a44e; color: #0a0f0a; font-size: 9px; font-weight: bold; padding: 1px 5px; border-radius: 1px; }
    .cat-card-tag { font-size: 7px; padding: 1px 4px; border-radius: 1px; font-weight: bold; text-transform: uppercase; letter-spacing: 0.5px; }
    .tag-swarm { background: rgba(76,175,80,0.15); color: #66bb6a; }
    .tag-offense { background: rgba(198,40,40,0.15); color: #ef5350; }
    .tag-tank { background: rgba(141,110,99,0.15); color: #a1887f; }
    .tag-ranged { background: rgba(230,168,23,0.15); color: #e6a817; }
    .tag-special { background: rgba(183,28,28,0.15); color: #ef5350; }
    .cat-card-desc { font-size: 8px; color: #5a6b5a; line-height: 1.3; }
    .cat-card-stats { font-size: 7px; color: #3a4a3a; margin-top: 2px; }

    .deck-actions { display: flex; gap: 8px; justify-content: center; margin-top: 10px; padding-bottom: 20px; }
    .deck-btn { padding: 12px 32px; font-size: 13px; font-weight: bold; border: none; border-radius: 2px; cursor: pointer; transition: all 0.12s; letter-spacing: 1px; text-transform: uppercase; }
    #btn-fight { background: #c5a44e; color: #0a0f0a; }
    #btn-fight:hover { background: #d4b45e; }
    #btn-fight:disabled { opacity: 0.3; cursor: not-allowed; }
    #btn-edit-deck { background: #1e2e1e; color: #7a8a7a; border: 1px solid #2a3a2a; }

    /* ===== HOME SCREEN ===== */
    #home-screen { background: linear-gradient(180deg, #0d1a0d, #0a0f0a); justify-content: center; }
    .home-title { font-size: 48px; font-weight: 900; letter-spacing: 6px; color: #c5a44e; text-shadow: 0 2px 8px rgba(160,130,50,0.3); font-family: Georgia, serif; }
    .home-sub { font-size: 11px; color: #5a6b5a; letter-spacing: 4px; margin: 4px 0 6px; text-transform: uppercase; }
    .home-username { font-size: 13px; color: #7a8a7a; margin-bottom: 24px; }
    .home-btn { width: 220px; padding: 13px; margin: 5px; font-size: 14px; font-weight: bold; border: none; border-radius: 2px; cursor: pointer; letter-spacing: 2px; text-transform: uppercase; transition: all 0.12s; }
    .home-btn:hover { transform: scale(1.02); }
    #btn-ai { background: #c5a44e; color: #0a0f0a; }
    #btn-online { background: #1e2e1e; color: #c5a44e; border: 1px solid #c5a44e; }
    #btn-deck { background: #141e14; color: #5a6b5a; border: 1px solid #2a3a2a; }
    .home-footer { position: absolute; bottom: 12px; font-size: 10px; color: #1e2e1e; letter-spacing: 2px; }

    /* ===== MATCHMAKING ===== */
    #matchmaking { background: rgba(10,15,10,0.95); justify-content: center; }
    .mm-spinner { width: 40px; height: 40px; border: 3px solid #1e2e1e; border-top-color: #c5a44e; border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px; }
    @keyframes spin { to { transform: rotate(360deg); } }
    .mm-text { font-size: 16px; margin-bottom: 16px; color: #7a8a7a; }
    .mm-cancel { padding: 10px 28px; background: #1e2e1e; color: #7a8a7a; border: 1px solid #2a3a2a; border-radius: 2px; cursor: pointer; font-size: 12px; text-transform: uppercase; letter-spacing: 1px; }

    /* ===== IN-GAME HUD ===== */
    #hud { position: absolute; bottom: 0; left: 0; right: 0; background: linear-gradient(180deg, rgba(10,15,10,0) 0%, rgba(10,15,10,0.92) 25%); padding: 6px 6px 8px; pointer-events: none; z-index: 10; }
    #elixir-bar-wrap { pointer-events: auto; margin: 0 8px 4px; }
    #elixir-bar { height: 16px; background: #141e14; border-radius: 2px; position: relative; overflow: hidden; border: 1px solid #2a3a2a; }
    #elixir-fill { height: 100%; background: linear-gradient(90deg, #c5a44e, #d4b45e); border-radius: 2px; transition: width 0.1s; }
    #elixir-text { position: absolute; inset: 0; text-align: center; font-size: 11px; font-weight: bold; line-height: 16px; color: white; text-shadow: 0 1px 2px black; }
    #cards { display: flex; justify-content: center; gap: 5px; pointer-events: auto; }
    #next-card { position: absolute; right: 6px; bottom: 104px; width: 36px; height: 44px; background: rgba(10,15,10,0.8); border: 1px solid #2a3a2a; border-radius: 2px; display: flex; align-items: center; justify-content: center; flex-direction: column; pointer-events: none; z-index: 10; }
    #next-card-label { position: absolute; right: 6px; bottom: 150px; font-size: 8px; color: #3a4a3a; text-align: center; width: 36px; z-index: 10; text-transform: uppercase; letter-spacing: 1px; }
    .card { width: 64px; height: 82px; background: #111a11; border: 1px solid #2a3a2a; border-radius: 2px; cursor: pointer; user-select: none; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: all 0.12s; position: relative; }
    .card:hover:not(.disabled) { border-color: #c5a44e; transform: translateY(-3px); }
    .card.selected { border-color: #c5a44e; box-shadow: 0 0 10px rgba(197,164,78,0.3); transform: translateY(-5px); }
    .card.disabled { opacity: 0.3; cursor: not-allowed; }
    .card-name { font-size: 7px; margin-top: 2px; color: #7a8a7a; text-transform: uppercase; letter-spacing: 0.3px; }
    .card-stats { font-size: 7px; color: #3a4a3a; }
    .card-cost { position: absolute; top: 3px; left: 5px; background: #c5a44e; color: #0a0f0a; min-width: 16px; height: 16px; border-radius: 1px; font-size: 10px; font-weight: bold; display: flex; align-items: center; justify-content: center; padding: 0 2px; }

    /* ===== OVERLAY ===== */
    #overlay { position: absolute; inset: 0; background: rgba(10,15,10,0.85); display: none; align-items: center; justify-content: center; flex-direction: column; z-index: 100; }
    #overlay.show { display: flex; }
    #overlay h1 { font-size: 40px; margin-bottom: 8px; font-family: Georgia, serif; letter-spacing: 3px; }
    #overlay p { font-size: 13px; color: #5a6b5a; margin-bottom: 24px; }
    .overlay-btns { display: flex; gap: 8px; }
    .overlay-btns button { padding: 12px 32px; font-size: 13px; font-weight: bold; background: #c5a44e; color: #0a0f0a; border: none; border-radius: 2px; cursor: pointer; letter-spacing: 1px; text-transform: uppercase; }
    .overlay-btns button:hover { background: #d4b45e; }
    .overlay-btns button.secondary { background: #1e2e1e; color: #7a8a7a; border: 1px solid #2a3a2a; }
    #timer { position: absolute; top: 8px; left: 50%; transform: translateX(-50%); font-size: 13px; font-weight: bold; color: #5a6b5a; z-index: 10; background: rgba(10,15,10,0.7); padding: 2px 14px; border-radius: 2px; border: 1px solid #1e2e1e; letter-spacing: 1px; }
    #player-name-hud { position: absolute; bottom: 108px; left: 8px; font-size: 10px; color: rgba(197,164,78,0.5); z-index: 10; }
    #ai-name-hud { position: absolute; top: 8px; right: 8px; font-size: 10px; color: rgba(180,60,60,0.5); z-index: 10; }
  </style>
</head>
<body>
<div id="game-container">
  <canvas id="arena"></canvas>
  <div id="timer" style="display:none">3:00</div>
  <div id="player-name-hud" style="display:none"></div>
  <div id="ai-name-hud" style="display:none"></div>
  <div id="next-card-label" style="display:none">NEXT</div>
  <div id="next-card" style="display:none"></div>
  <div id="hud" style="display:none">
    <div id="elixir-bar-wrap"><div id="elixir-bar"><div id="elixir-fill"></div><div id="elixir-text">5 / 10</div></div></div>
    <div id="cards"></div>
  </div>

  <!-- WELCOME -->
  <div id="welcome-screen" class="screen show">
    <div class="welcome-title">PATRIOT</div>
    <div class="welcome-sub">DRAIN THE SWAMP</div>
    <div class="welcome-label">ENTER YOUR CALLSIGN</div>
    <input id="username-input" type="text" placeholder="Username" maxlength="16" autocomplete="off" spellcheck="false">
    <button class="welcome-go" id="btn-welcome-go">ENTER</button>
  </div>

  <!-- DECK BUILDER -->
  <div id="deck-screen" class="screen"></div>

  <!-- HOME SCREEN -->
  <div id="home-screen" class="screen">
    <div class="home-title">PATRIOT</div>
    <div class="home-sub">DRAIN THE SWAMP</div>
    <div class="home-username" id="home-user"></div>
    <button class="home-btn" id="btn-ai">VS COMPUTER</button>
    <button class="home-btn" id="btn-online">PLAY ONLINE</button>
    <button class="home-btn" id="btn-deck">EDIT DECK</button>
    <div class="home-footer">UFCR.ONLINE</div>
  </div>

  <!-- MATCHMAKING -->
  <div id="matchmaking" class="screen">
    <div class="mm-spinner"></div>
    <div class="mm-text" id="mm-status">Searching for opponent...</div>
    <button class="mm-cancel" onclick="cancelMatchmaking()">CANCEL</button>
  </div>

  <!-- SERVER FULL -->
  <div id="full-screen" class="screen">
    <div style="font-family:Georgia,serif;font-size:28px;color:#c5a44e;margin-bottom:12px;letter-spacing:2px;">ROUNDS FULL</div>
    <div style="font-size:13px;color:#5a6b5a;margin-bottom:24px;text-align:center;max-width:260px;">All 50 matches are currently in progress. Please try again shortly.</div>
    <button class="mm-cancel" onclick="showHomeScreen()">BACK TO HOME</button>
  </div>

  <!-- GAME OVER -->
  <div id="overlay">
    <h1 id="result-text"></h1>
    <p id="result-sub"></p>
    <div class="overlay-btns">
      <button onclick="playAgain()">PLAY AGAIN</button>
      <button class="secondary" onclick="returnHome()">HOME</button>
    </div>
  </div>
</div>

<script>
// ============================================================
//  FIREBASE CONFIG
// ============================================================
const firebaseConfig = {
  apiKey: "AIzaSyA0w9Ec_5pQ8K-cJYY-5piyoZ9xLJfTFIM",
  authDomain: "ufcr-patriot.firebaseapp.com",
  databaseURL: "https://ufcr-patriot-default-rtdb.firebaseio.com",
  projectId: "ufcr-patriot",
  storageBucket: "ufcr-patriot.firebasestorage.app",
  messagingSenderId: "813225836179",
  appId: "1:813225836179:web:1cdd98560f7bb1d9099766"
};
const MAX_MATCHES = 50;
let fb, fbDb, matchRef, gameRef, playerId, opponentName;
let isOnline = false, isHost = false, fbInited = false;
let myMatchId = null;
let deployListener = null;
let disconnectRef = null;

function initFirebase() {
  if (fbInited) return;
  try {
    fb = firebase.initializeApp(firebaseConfig);
    fbDb = firebase.database();
    playerId = 'p_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
    fbInited = true;
  } catch(e) { console.warn('Firebase init failed:', e); }
}

// ============================================================
//  MULTIPLAYER: Matchmaking with 50-match cap
// ============================================================
async function startOnline() {
  initFirebase();
  if (!fbInited) {
    alert('Online play is being set up. Check back soon!');
    return;
  }
  showScreen('matchmaking');
  document.getElementById('mm-status').textContent = 'Checking available slots...';
  gameState = 'matchmaking'; isOnline = true;

  try {
    const snap = await fbDb.ref('matches').once('value');
    const matches = snap.val() || {};
    const now = Date.now();
    let activeCount = 0;
    for (const [id, m] of Object.entries(matches)) {
      const age = now - (m.createdAt || m.startedAt || 0);
      const isStale = (m.status === 'waiting' && age > 5 * 60 * 1000) ||
                      (m.status === 'playing' && age > 10 * 60 * 1000);
      if (isStale) {
        fbDb.ref('matches/' + id).remove().catch(() => {});
      } else if (m.status === 'playing' || m.status === 'waiting') {
        activeCount++;
      }
    }

    if (activeCount >= MAX_MATCHES) {
      showScreen('full-screen');
      return;
    }

    document.getElementById('mm-status').textContent = 'Searching for opponent...';

    const lobbySnap = await fbDb.ref('matches').orderByChild('status').equalTo('waiting').limitToFirst(1).once('value');
    const lobbies = lobbySnap.val();

    if (lobbies) {
      const matchId = Object.keys(lobbies)[0];
      const lobby = lobbies[matchId];
      // Don't join our own lobby
      if (lobby.host === playerId) {
        createLobby();
        return;
      }
      myMatchId = matchId;
      isHost = false;
      opponentName = lobby.hostName || 'Opponent';
      gameRef = fbDb.ref('matches/' + matchId);

      await gameRef.update({
        guest: playerId,
        guestName: username,
        guestDeck: playerDeck,
        status: 'playing',
        startedAt: firebase.database.ServerValue.TIMESTAMP
      });

      setupDisconnect();
      beginOnlineGame(lobby.hostDeck || []);
    } else {
      createLobby();
    }
  } catch(e) {
    console.error('Matchmaking error:', e);
    alert('Connection error. Try again.');
    showHomeScreen();
  }
}

function createLobby() {
  matchRef = fbDb.ref('matches').push();
  myMatchId = matchRef.key;
  isHost = true;
  gameRef = matchRef;

  matchRef.set({
    host: playerId,
    hostName: username,
    hostDeck: playerDeck,
    status: 'waiting',
    createdAt: firebase.database.ServerValue.TIMESTAMP
  });

  setupDisconnect();

  document.getElementById('mm-status').textContent = 'Waiting for opponent...';

  matchRef.on('value', snap => {
    const data = snap.val();
    if (!data) { cancelMatchmaking(); return; }
    if (data.guest && data.status === 'playing') {
      matchRef.off('value');
      opponentName = data.guestName || 'Opponent';
      beginOnlineGame(data.guestDeck || []);
    }
  });
}

function setupDisconnect() {
  if (!gameRef || !myMatchId) return;
  disconnectRef = fbDb.ref('matches/' + myMatchId);
  if (isHost) {
    disconnectRef.onDisconnect().remove();
  }
  const myRole = isHost ? 'hostDisconnected' : 'guestDisconnected';
  fbDb.ref('matches/' + myMatchId + '/' + myRole).onDisconnect().set(true);
}

function cancelMatchmaking() {
  if (myMatchId) {
    fbDb.ref('matches/' + myMatchId).remove().catch(() => {});
  }
  if (gameRef) { gameRef.off(); gameRef = null; }
  if (matchRef) { matchRef.off(); matchRef = null; }
  if (disconnectRef) { disconnectRef.onDisconnect().cancel(); }
  myMatchId = null;
  deployListener = null;
  showHomeScreen();
  isOnline = false;
}

// ============================================================
//  MULTIPLAYER: Game sync — HOST IS AUTHORITATIVE
// ============================================================
// Both players sync deploys. Host also syncs tower HP periodically
// and game result. Guest reads host's tower state as ground truth.

function sendDeploy(type, x, y) {
  if (!gameRef || !myMatchId) return;
  const role = isHost ? 'hostDeploys' : 'guestDeploys';
  // Normalize to 0-1 using fixed reference resolution
  const scaleX = SYNC_W / W, scaleY = SYNC_H / H;
  fbDb.ref('matches/' + myMatchId + '/' + role).push({
    type, x: (x * scaleX) / SYNC_W, y: (y * scaleY) / SYNC_H,
    t: firebase.database.ServerValue.TIMESTAMP
  });
}

// Host sends game state snapshot every 1.5 seconds (towers + units)
let lastStateSync = 0;
let unitIdCounter = 0;
function syncGameState() {
  if (!isHost || !myMatchId || !fbDb) return;
  const now = Date.now();
  if (now - lastStateSync < 1000) return;
  lastStateSync = now;

  const towerState = towers.map(t => ({ hp: Math.round(t.hp) }));

  // Normalize positions to 0-1 using fixed reference resolution
  // This ensures different screen sizes/DPRs don't cause offset errors
  const scaleX = SYNC_W / W, scaleY = SYNC_H / H;
  const unitState = units.map(u => {
    let vx = 0, vy = 0;
    if (u.wpIdx < u.waypoints.length) {
      const wp = u.waypoints[u.wpIdx];
      const dx = wp.x - u.x, dy = wp.y - u.y, d = Math.hypot(dx, dy);
      if (d > 1) { vx = (dx/d) * u.spd * scaleX / SYNC_W; vy = (dy/d) * u.spd * scaleY / SYNC_H; }
    }
    return {
      t: u.type,
      s: u.side === 'player' ? 0 : 1,
      x: +((u.x * scaleX) / SYNC_W).toFixed(4),
      y: +((u.y * scaleY) / SYNC_H).toFixed(4),
      h: Math.round(u.hp),
      vx: +vx.toFixed(4),
      vy: +vy.toFixed(4),
      id: u.syncId || (u.syncId = ++unitIdCounter)
    };
  });

  fbDb.ref('matches/' + myMatchId + '/gameState').set({
    towers: towerState,
    units: unitState,
    time: Math.round(gameTime),
    elixir: Math.round(elixir)
  }).catch(() => {});
}

// Host sends game result — single source of truth
function sendGameResult(hostWon) {
  if (!isHost || !myMatchId || !fbDb) return;
  fbDb.ref('matches/' + myMatchId + '/result').set({
    winner: hostWon ? 'host' : 'guest',
    t: firebase.database.ServerValue.TIMESTAMP
  }).catch(() => {});
}

// Guest listens for host's game state and result
function listenForHostState() {
  if (isHost || !myMatchId) return;

  // Listen for combined game state (towers + units)
  fbDb.ref('matches/' + myMatchId + '/gameState').on('value', snap => {
    const state = snap.val();
    if (!state) return;

    // Apply tower HP (flipped perspective)
    if (state.towers && state.towers.length >= 6) {
      const t = state.towers;
      towers[3].hp = t[0].hp; // host ai -> guest player
      towers[4].hp = t[1].hp;
      towers[5].hp = t[2].hp;
      towers[0].hp = t[3].hp; // host player -> guest ai
      towers[1].hp = t[4].hp;
      towers[2].hp = t[5].hp;
    }

    // Reconcile units with host's authoritative state
    if (state.units) {
      reconcileUnits(state.units);
    }

    // Sync game timer
    if (state.time !== undefined) {
      gameTime = state.time;
    }
  });

  // Listen for authoritative game result from host
  fbDb.ref('matches/' + myMatchId + '/result').on('value', snap => {
    const result = snap.val();
    if (!result || gameOver) return;
    const iWon = (result.winner === 'guest');
    endGame(iWon, iWon ? 'The swamp has been drained.' : 'The deep state wins... for now.');
  });
}

// Reconcile guest's local units with host's snapshot
function reconcileUnits(hostUnits) {
  const hostMap = new Map();
  hostUnits.forEach(hu => hostMap.set(hu.id, hu));

  // Remove local units that host no longer has (they died)
  for (let i = units.length - 1; i >= 0; i--) {
    if (units[i].syncId && !hostMap.has(units[i].syncId)) {
      spawnDeathFX(units[i].x, units[i].y, units[i].color);
      units.splice(i, 1);
    }
  }

  // Update existing and add new units
  // Denormalize from 0-1 to guest's actual canvas dimensions
  const gScaleX = W / SYNC_W, gScaleY = H / SYNC_H;
  hostUnits.forEach(hu => {
    const guestSide = hu.s === 0 ? 'ai' : 'player'; // flip sides
    const guestX = hu.x * SYNC_W * gScaleX;
    const guestY = (FLIP_Y_AXIS - hu.y) * SYNC_H * gScaleY; // flip around board center

    const local = units.find(u => u.syncId === hu.id);
    if (local) {
      local.targetX = guestX;
      local.targetY = guestY;
      local.velX = (hu.vx || 0) * SYNC_W * gScaleX;
      local.velY = -(hu.vy || 0) * SYNC_H * gScaleY; // negate Y velocity for flip
      local.hp = hu.h;
      local.side = guestSide;
    } else {
      const def = ALL_CARDS[hu.t];
      if (!def) return;
      units.push({
        type: hu.t, side: guestSide,
        x: guestX, y: guestY,
        targetX: guestX, targetY: guestY,
        hp: hu.h, maxHp: def.hp,
        dmg: def.dmg, spd: def.spd * (W/360),
        range: S(def.range), atkSpd: def.atkSpd,
        atkTimer: 0, color: def.color,
        poison: def.poison||0, splash: S(def.splash||0),
        ranged: def.ranged||false, shield: def.shield||0,
        splits: def.splits||false,
        waypoints:[], wpIdx:0, poisonTimer:0,
        animPhase: Math.random()*Math.PI*2,
        lastTargetCalc: 0,
        syncId: hu.id
      });
    }
  });
}

let processedDeploys = new Set();
function listenForOpponentDeploys() {
  const role = isHost ? 'guestDeploys' : 'hostDeploys';
  const ref = fbDb.ref('matches/' + myMatchId + '/' + role);
  ref.on('child_added', snap => {
    // Deduplicate — child_added fires for historical entries too
    if (processedDeploys.has(snap.key)) return;
    processedDeploys.add(snap.key);
    const d = snap.val();
    if (!d) return;
    // Denormalize from 0-1 to host's actual canvas dimensions
    const hScaleX = W / SYNC_W, hScaleY = H / SYNC_H;
    const mx = d.x * SYNC_W * hScaleX;
    const my = (FLIP_Y_AXIS - d.y) * SYNC_H * hScaleY;
    spawnUnit(d.type, mx, my, 'ai');
  });
}

function listenForOpponentDisconnect() {
  if (!myMatchId) return;
  const otherRole = isHost ? 'guestDisconnected' : 'hostDisconnected';
  fbDb.ref('matches/' + myMatchId + '/' + otherRole).on('value', snap => {
    if (snap.val() === true && gameState === 'playing' && !gameOver) {
      endGame(true, 'Opponent disconnected');
      cleanupMatch();
    }
  });
}

function cleanupMatch() {
  if (myMatchId) {
    // Remove all listeners
    fbDb.ref('matches/' + myMatchId + '/gameState').off();
    fbDb.ref('matches/' + myMatchId + '/result').off();
    const role = isHost ? 'guestDeploys' : 'hostDeploys';
    fbDb.ref('matches/' + myMatchId + '/' + role).off();
    const otherRole = isHost ? 'guestDisconnected' : 'hostDisconnected';
    fbDb.ref('matches/' + myMatchId + '/' + otherRole).off();
    fbDb.ref('matches/' + myMatchId).remove().catch(() => {});
  }
  if (gameRef) { gameRef.off(); }
  if (disconnectRef) { disconnectRef.onDisconnect().cancel(); }
  myMatchId = null;
  deployListener = null;
}

function beginOnlineGame(opponentDeck) {
  showScreen(null);
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('show'));
  vsAI = false;
  isOnline = true;
  initGame();
  if (isHost) {
    // Host listens for guest deploys to spawn them into its simulation
    listenForOpponentDeploys();
  } else {
    // Guest gets ALL state from host's gameState sync — no deploy listener needed
    listenForHostState();
  }
  listenForOpponentDisconnect();
}

// ============================================================
//  COOKIE HELPERS
// ============================================================
function saveCookie(key, val) {
  const d = new Date(); d.setFullYear(d.getFullYear() + 2);
  document.cookie = `patriot_${key}=${encodeURIComponent(JSON.stringify(val))};expires=${d.toUTCString()};path=/;SameSite=Lax`;
}
function loadCookie(key) {
  const m = document.cookie.match(new RegExp(`patriot_${key}=([^;]+)`));
  if (!m) return null;
  try { return JSON.parse(decodeURIComponent(m[1])); } catch { return null; }
}

// ============================================================
//  CONSTANTS
// ============================================================
let W = 360, H = 640;
// Fixed reference resolution for network sync (never changes)
const SYNC_W = 360, SYNC_H = 640;
// Board flip axis — average of AI king center (0.0655) and Player king center (0.7465)
// Used to mirror Y positions between host and guest perspectives
const FLIP_Y_AXIS = 0.812; // sum of the two centers; flipped = FLIP_Y_AXIS - y
let RIVER_TOP, RIVER_BOT, RIVER_MID, BRIDGE_L, BRIDGE_R, DEPLOY_MIN_Y, DEPLOY_MAX_Y;
function recalcLayout() {
  RIVER_TOP = H * 0.441;
  RIVER_BOT = H * 0.497;
  RIVER_MID = (RIVER_TOP + RIVER_BOT) / 2;
  BRIDGE_L = { x1: W * 0.111, x2: W * 0.333, cy: RIVER_MID };
  BRIDGE_R = { x1: W * 0.667, x2: W * 0.889, cy: RIVER_MID };
  DEPLOY_MIN_Y = H / 2 + H * 0.016;
  DEPLOY_MAX_Y = H - H * 0.188;
}
const MAX_ELIXIR = 10, GAME_DURATION = 180, OT_DURATION = 60;
const DECK_SIZE = 8;

// ============================================================
//  CARD DEFINITIONS (12 cards)
// ============================================================
const ALL_CARDS = {
  lobbyist: {
    name: 'Lobbyist Lizard', cost: 3, hp: 180, dmg: 16, spd: 1.1, range: 22, atkSpd: 0.7,
    color: '#4caf50', count: 3,
    category: 'swarm', tag: 'Swarm', tagClass: 'tag-swarm',
    desc: 'Deploys 3 fast lizards that overwhelm with numbers. Weak alone but deadly in packs.',
    flavorStats: 'HP 180 · DMG 16 · SPD Fast · x3 units'
  },
  viper: {
    name: 'Venom Viper', cost: 3, hp: 200, dmg: 10, spd: 0.9, range: 28, atkSpd: 0.6,
    color: '#8bc34a', count: 2, poison: 6,
    category: 'offense', tag: 'Offense', tagClass: 'tag-offense',
    desc: 'Twin vipers with toxic bite. Poison continues damaging enemies after the attack.',
    flavorStats: 'HP 200 · DMG 10+poison · SPD Med · x2 units'
  },
  behemoth: {
    name: 'Bureaucrat Behemoth', cost: 5, hp: 700, dmg: 40, spd: 0.4, range: 22, atkSpd: 1.3,
    color: '#795548', count: 1, splash: 45,
    category: 'tank', tag: 'Heavy', tagClass: 'tag-tank',
    desc: 'Massive armored beast. Slow but devastating splash damage crushes groups.',
    flavorStats: 'HP 700 · DMG 40 splash · SPD Slow'
  },
  assassin: {
    name: 'Shadow Assassin', cost: 4, hp: 130, dmg: 55, spd: 1.5, range: 18, atkSpd: 0.9,
    color: '#9c27b0', count: 1,
    category: 'offense', tag: 'Offense', tagClass: 'tag-offense',
    desc: 'Lightning-fast glass cannon. Insane damage but paper-thin HP. Use to snipe key targets.',
    flavorStats: 'HP 130 · DMG 55 · SPD Very Fast'
  },
  gator: {
    name: 'Swamp Gator', cost: 4, hp: 450, dmg: 28, spd: 0.7, range: 20, atkSpd: 1.0,
    color: '#00796b', count: 1,
    category: 'tank', tag: 'Heavy', tagClass: 'tag-tank',
    desc: 'Tough mid-cost bruiser. Good HP and decent damage -- reliable frontline fighter.',
    flavorStats: 'HP 450 · DMG 28 · SPD Med'
  },
  filibuster: {
    name: 'Filibuster Frog', cost: 2, hp: 100, dmg: 8, spd: 1.3, range: 18, atkSpd: 0.5,
    color: '#26c6da', count: 4,
    category: 'swarm', tag: 'Swarm', tagClass: 'tag-swarm',
    desc: 'Cheapest card. Spawns 4 tiny frogs that swarm and distract. Great cycle card.',
    flavorStats: 'HP 100 · DMG 8 · SPD Fast · x4 units'
  },
  sniper: {
    name: 'Sniper Salamander', cost: 4, hp: 160, dmg: 65, spd: 0.5, range: 100, atkSpd: 2.0,
    color: '#ffa000', count: 1, ranged: true,
    category: 'ranged', tag: 'Ranged', tagClass: 'tag-ranged',
    desc: 'Extreme range, extreme damage, extreme vulnerability. Place behind tanks for max value.',
    flavorStats: 'HP 160 · DMG 65 · RNG Long · SPD Slow'
  },
  cobra: {
    name: 'Corruption Cobra', cost: 5, hp: 300, dmg: 20, spd: 0.55, range: 60, atkSpd: 1.2,
    color: '#c62828', count: 1, ranged: true, poison: 8, splash: 35,
    category: 'ranged', tag: 'Ranged', tagClass: 'tag-ranged',
    desc: 'Ranged area-of-effect poison. Melts groups from a distance. The ultimate support unit.',
    flavorStats: 'HP 300 · DMG 20+poison AoE · RNG Long'
  },
  drake: {
    name: 'Deep State Drake', cost: 7, hp: 800, dmg: 50, spd: 0.55, range: 25, atkSpd: 1.4,
    color: '#4a148c', count: 1, splash: 50,
    category: 'special', tag: 'Boss', tagClass: 'tag-special',
    desc: 'The ultimate weapon. Massive HP, huge splash damage. Worth every drop of elixir.',
    flavorStats: 'HP 800 · DMG 50 splash · SPD Med'
  },
  insider: {
    name: 'Insider Iguana', cost: 3, hp: 250, dmg: 22, spd: 0.85, range: 22, atkSpd: 0.8,
    color: '#558b2f', count: 2,
    category: 'offense', tag: 'Offense', tagClass: 'tag-offense',
    desc: 'Well-rounded pair of fighters. Jack of all trades -- solid in any deck.',
    flavorStats: 'HP 250 · DMG 22 · SPD Med · x2 units'
  },
  sentinel: {
    name: 'Sentinel Shell', cost: 6, hp: 900, dmg: 15, spd: 0.35, range: 20, atkSpd: 1.5,
    color: '#37474f', count: 1, shield: 200,
    category: 'tank', tag: 'Defense', tagClass: 'tag-tank',
    desc: 'The wall. Energy shield absorbs the first 200 damage. Slow but nearly unkillable.',
    flavorStats: 'HP 900 + 200 shield · DMG 15 · SPD Slow'
  },
  splitter: {
    name: 'Gerrymander', cost: 4, hp: 200, dmg: 25, spd: 1.0, range: 20, atkSpd: 0.8,
    color: '#e65100', count: 1, splits: true,
    category: 'special', tag: 'Special', tagClass: 'tag-special',
    desc: 'Splits into 2 smaller units on death. Hard to fully remove -- they just keep coming.',
    flavorStats: 'HP 200 · DMG 25 · Splits into x2 on death'
  }
};

const CARD_KEYS = Object.keys(ALL_CARDS);
const CATEGORIES = [
  { key: 'swarm',   label: 'SWARM',   cls: 'cat-swarm' },
  { key: 'offense', label: 'OFFENSE', cls: 'cat-offense' },
  { key: 'tank',    label: 'HEAVY / DEFENSE', cls: 'cat-tank' },
  { key: 'ranged',  label: 'RANGED',  cls: 'cat-ranged' },
  { key: 'special', label: 'SPECIAL', cls: 'cat-special' }
];

// ============================================================
//  GAME STATE
// ============================================================
let canvas, ctx;
let gameState = 'welcome';
let vsAI = true;
let username = '';
let playerDeck = [];

let elixir, aiElixir, elixirRate;
let units, projectiles, particles, dmgNums;
let towers;
let gameTime, overtime, gameOver, lastFrameTime;
let selectedCard;

let deck = [], hand = [], nextCard = null, deckQueue = [];

// AI
let aiDeck = [], aiHand = [], aiNext = null, aiQueue = [], aiDeployTimer = 0;

// ============================================================
//  INIT / COOKIE LOAD
// ============================================================
function loadProfile() {
  const u = loadCookie('username');
  const d = loadCookie('deck');
  if (u) username = u;
  if (d && Array.isArray(d) && d.length === DECK_SIZE && d.every(k => ALL_CARDS[k])) {
    playerDeck = d;
  }
}

function saveProfile() {
  saveCookie('username', username);
  saveCookie('deck', playerDeck);
}

// ============================================================
//  SCREEN MANAGEMENT
// ============================================================
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('show'));
  const el = document.getElementById(id);
  if (el) el.classList.add('show');
  ['hud','timer','next-card','next-card-label','player-name-hud','ai-name-hud'].forEach(x => {
    const e = document.getElementById(x);
    if (e) e.style.display = 'none';
  });
  document.getElementById('overlay').classList.remove('show');
}

// ============================================================
//  WELCOME SCREEN
// ============================================================
function initWelcome() {
  const inp = document.getElementById('username-input');
  if (username) inp.value = username;
  inp.addEventListener('keydown', e => { if (e.key === 'Enter') submitUsername(); });
  document.getElementById('btn-welcome-go').addEventListener('click', submitUsername);
}

function submitUsername() {
  const inp = document.getElementById('username-input');
  const val = inp.value.trim();
  if (!val) { inp.style.borderColor = '#f44336'; return; }
  username = val;
  saveProfile();
  if (playerDeck.length === DECK_SIZE) {
    showHomeScreen();
  } else {
    showDeckBuilder();
  }
}

// ============================================================
//  DECK BUILDER
// ============================================================
function showDeckBuilder(fromHome) {
  showScreen('deck-screen');
  gameState = 'deck';
  buildDeckUI(fromHome);
  // Scroll to top when opening
  document.getElementById('deck-screen').scrollTop = 0;
}

function buildDeckUI(fromHome) {
  const screen = document.getElementById('deck-screen');
  let html = `
    <div class="deck-header">
      <h2>BUILD YOUR DECK</h2>
      <p>Select ${DECK_SIZE} cards for battle</p>
    </div>
    <div class="deck-username" onclick="changeUsername()">Playing as: <b>${username}</b> [edit]</div>
    <div id="my-deck"></div>
    <div id="deck-count">${playerDeck.length} / ${DECK_SIZE} selected</div>
    <div id="deck-avg"></div>
  `;

  CATEGORIES.forEach(cat => {
    const cards = CARD_KEYS.filter(k => ALL_CARDS[k].category === cat.key);
    html += `<div class="catalog-section ${cat.cls}"><h3>${cat.label}</h3><div class="catalog-grid">`;
    cards.forEach(key => {
      const c = ALL_CARDS[key];
      const inDeck = playerDeck.includes(key);
      html += `
        <div class="cat-card ${inDeck ? 'in-deck' : ''}" data-key="${key}" onclick="toggleDeckCard('${key}')">
          <div class="cat-card-icon"><canvas width="48" height="48" data-icon="${key}"></canvas></div>
          <div class="cat-card-info">
            <div class="cat-card-top">
              <span class="cat-card-name">${c.name}</span>
              <span class="cat-card-cost">${c.cost}</span>
              <span class="cat-card-tag ${c.tagClass}">${c.tag}</span>
            </div>
            <div class="cat-card-desc">${c.desc}</div>
            <div class="cat-card-stats">${c.flavorStats}</div>
          </div>
        </div>`;
    });
    html += `</div></div>`;
  });

  html += `<div class="deck-actions">
    ${fromHome ? '<button class="deck-btn" id="btn-edit-deck" onclick="showHomeScreen()">BACK</button>' : ''}
    <button class="deck-btn" id="btn-fight" onclick="deckDone()" ${playerDeck.length < DECK_SIZE ? 'disabled' : ''}>FIGHT</button>
  </div>`;

  screen.innerHTML = html;

  screen.querySelectorAll('canvas[data-icon]').forEach(cvs => {
    drawDetailedIcon(cvs, cvs.dataset.icon, 48);
  });

  refreshDeckSlots();
}

function toggleDeckCard(key) {
  const idx = playerDeck.indexOf(key);
  if (idx >= 0) {
    playerDeck.splice(idx, 1);
  } else if (playerDeck.length < DECK_SIZE) {
    playerDeck.push(key);
  }
  saveProfile();
  document.querySelectorAll('.cat-card').forEach(el => {
    el.classList.toggle('in-deck', playerDeck.includes(el.dataset.key));
  });
  document.getElementById('deck-count').textContent = `${playerDeck.length} / ${DECK_SIZE} selected`;
  const btn = document.getElementById('btn-fight');
  if (btn) btn.disabled = playerDeck.length < DECK_SIZE;
  refreshDeckSlots();
  updateDeckAvg();
}

function refreshDeckSlots() {
  const container = document.getElementById('my-deck');
  container.innerHTML = '';
  for (let i = 0; i < DECK_SIZE; i++) {
    const slot = document.createElement('div');
    slot.className = 'deck-slot' + (playerDeck[i] ? ' filled' : '');
    if (playerDeck[i]) {
      const c = ALL_CARDS[playerDeck[i]];
      slot.innerHTML = `<span class="slot-cost">${c.cost}</span><canvas width="32" height="32"></canvas><span class="slot-name">${c.name.split(' ')[0]}</span>`;
      slot.onclick = () => toggleDeckCard(playerDeck[i]);
      drawDetailedIcon(slot.querySelector('canvas'), playerDeck[i], 32);
    } else {
      slot.innerHTML = '<span style="color:#333;font-size:16px">+</span>';
    }
    container.appendChild(slot);
  }
}

function updateDeckAvg() {
  const el = document.getElementById('deck-avg');
  if (!el || playerDeck.length === 0) { if(el) el.textContent = ''; return; }
  const avg = playerDeck.reduce((s,k) => s + ALL_CARDS[k].cost, 0) / playerDeck.length;
  el.textContent = `Avg elixir: ${avg.toFixed(1)}`;
}

function deckDone() {
  if (playerDeck.length < DECK_SIZE) return;
  saveProfile();
  showHomeScreen();
}

function changeUsername() {
  const newName = prompt('Enter new callsign:', username);
  if (newName && newName.trim()) {
    username = newName.trim().slice(0, 16);
    saveProfile();
    showDeckBuilder(false);
  }
}

// ============================================================
//  DETAILED CARD ICON DRAWING
// ============================================================
function drawDetailedIcon(cvs, type, size) {
  const c = cvs.getContext('2d');
  c.clearRect(0, 0, size, size);
  const s = size / 48;
  c.save();
  c.translate(size/2, size/2);
  c.scale(s, s);

  const col = ALL_CARDS[type].color;

  switch(type) {
    case 'lobbyist': {
      [[-8,-6],[0,4],[8,-6]].forEach(([ox,oy]) => {
        c.fillStyle = col;
        c.beginPath(); c.ellipse(ox, oy, 6, 4, 0, 0, Math.PI*2); c.fill();
        c.strokeStyle = col; c.lineWidth = 1.5;
        c.beginPath(); c.moveTo(ox-3, oy+3); c.quadraticCurveTo(ox-8, oy+7, ox-5, oy+10); c.stroke();
        c.fillStyle = '#ffeb3b';
        c.beginPath(); c.arc(ox-2, oy-2, 1.5, 0, Math.PI*2); c.arc(ox+2, oy-2, 1.5, 0, Math.PI*2); c.fill();
        c.fillStyle = '#000';
        c.beginPath(); c.arc(ox-2, oy-2, 0.6, 0, Math.PI*2); c.arc(ox+2, oy-2, 0.6, 0, Math.PI*2); c.fill();
      });
      break;
    }
    case 'viper': {
      c.strokeStyle = col; c.lineWidth = 5; c.lineCap = 'round';
      c.beginPath(); c.moveTo(-8, 10);
      c.quadraticCurveTo(-14, 0, -6, -6);
      c.quadraticCurveTo(2, -12, 8, -4);
      c.quadraticCurveTo(14, 4, 6, 10);
      c.stroke();
      c.fillStyle = col;
      c.beginPath(); c.arc(-8, 10, 6, 0, Math.PI*2); c.fill();
      c.fillStyle = '#76ff03';
      c.beginPath(); c.arc(-6, 15, 2, 0, Math.PI*2); c.fill();
      c.beginPath(); c.arc(-3, 18, 1.2, 0, Math.PI*2); c.fill();
      c.fillStyle = '#f44336';
      c.beginPath(); c.arc(-10, 8, 2, 0, Math.PI*2); c.arc(-6, 8, 2, 0, Math.PI*2); c.fill();
      c.fillStyle = '#fff';
      c.beginPath(); c.moveTo(-9, 13); c.lineTo(-8, 17); c.lineTo(-7, 13); c.fill();
      c.beginPath(); c.moveTo(-6, 13); c.lineTo(-5, 17); c.lineTo(-4, 13); c.fill();
      break;
    }
    case 'behemoth': {
      c.fillStyle = col;
      c.beginPath(); c.moveTo(0, -18); c.lineTo(16, -6); c.lineTo(14, 14);
      c.lineTo(-14, 14); c.lineTo(-16, -6); c.closePath(); c.fill();
      c.strokeStyle = '#4e342e'; c.lineWidth = 1;
      c.beginPath(); c.moveTo(-12, -2); c.lineTo(12, -2); c.stroke();
      c.beginPath(); c.moveTo(-10, 6); c.lineTo(10, 6); c.stroke();
      c.strokeStyle = '#8d6e63'; c.lineWidth = 3; c.lineCap = 'round';
      c.beginPath(); c.moveTo(-10, -12); c.lineTo(-16, -22); c.stroke();
      c.beginPath(); c.moveTo(10, -12); c.lineTo(16, -22); c.stroke();
      c.fillStyle = '#ffab00';
      c.beginPath(); c.arc(-5, -8, 3, 0, Math.PI*2); c.arc(5, -8, 3, 0, Math.PI*2); c.fill();
      c.fillStyle = '#000';
      c.beginPath(); c.arc(-5, -8, 1.5, 0, Math.PI*2); c.arc(5, -8, 1.5, 0, Math.PI*2); c.fill();
      c.strokeStyle = '#3e2723'; c.lineWidth = 1.5;
      c.beginPath(); c.moveTo(-6, 2); c.lineTo(0, 5); c.lineTo(6, 2); c.stroke();
      break;
    }
    case 'assassin': {
      c.fillStyle = '#1a0030';
      c.beginPath(); c.moveTo(0, -16); c.lineTo(14, 0); c.lineTo(0, 16); c.lineTo(-14, 0); c.closePath(); c.fill();
      c.fillStyle = col;
      c.beginPath(); c.moveTo(0, -12); c.lineTo(10, 0); c.lineTo(0, 12); c.lineTo(-10, 0); c.closePath(); c.fill();
      c.strokeStyle = '#ce93d8'; c.lineWidth = 2;
      c.beginPath(); c.moveTo(-10, 0); c.lineTo(-18, -6); c.stroke();
      c.beginPath(); c.moveTo(10, 0); c.lineTo(18, -6); c.stroke();
      c.fillStyle = '#e1bee7';
      c.beginPath(); c.arc(-18, -6, 1.5, 0, Math.PI*2); c.fill();
      c.beginPath(); c.arc(18, -6, 1.5, 0, Math.PI*2); c.fill();
      c.fillStyle = '#e040fb';
      c.beginPath(); c.arc(-3, -3, 2.5, 0, Math.PI*2); c.arc(3, -3, 2.5, 0, Math.PI*2); c.fill();
      c.fillStyle = '#fff';
      c.beginPath(); c.arc(-3, -3, 1, 0, Math.PI*2); c.arc(3, -3, 1, 0, Math.PI*2); c.fill();
      break;
    }
    case 'gator': {
      c.fillStyle = col;
      c.beginPath(); c.ellipse(0, 2, 14, 10, 0, 0, Math.PI*2); c.fill();
      c.fillStyle = '#004d40';
      c.beginPath(); c.ellipse(0, -8, 10, 5, 0, 0, Math.PI*2); c.fill();
      c.fillStyle = '#fff'; c.strokeStyle = '#00695c'; c.lineWidth = 1;
      for (let i = -6; i <= 6; i += 3) {
        c.beginPath(); c.moveTo(i, -5); c.lineTo(i, -2); c.lineTo(i+1.5, -5); c.fill();
      }
      c.fillStyle = '#ffeb3b';
      c.beginPath(); c.arc(-5, -11, 2.5, 0, Math.PI*2); c.arc(5, -11, 2.5, 0, Math.PI*2); c.fill();
      c.fillStyle = '#000';
      c.beginPath(); c.arc(-5, -11, 1, 0, Math.PI*2); c.arc(5, -11, 1, 0, Math.PI*2); c.fill();
      c.strokeStyle = col; c.lineWidth = 4; c.lineCap = 'round';
      c.beginPath(); c.moveTo(0, 10); c.quadraticCurveTo(10, 16, 4, 20); c.stroke();
      break;
    }
    case 'filibuster': {
      [[-8,-6],[8,-6],[-4,6],[4,6]].forEach(([ox,oy]) => {
        c.fillStyle = col;
        c.beginPath(); c.arc(ox, oy, 5, 0, Math.PI*2); c.fill();
        c.fillStyle = '#000';
        c.beginPath(); c.arc(ox-2, oy-2, 1.2, 0, Math.PI*2); c.arc(ox+2, oy-2, 1.2, 0, Math.PI*2); c.fill();
        c.strokeStyle = col; c.lineWidth = 1;
        c.beginPath(); c.moveTo(ox-3, oy+4); c.lineTo(ox-6, oy+8);
        c.moveTo(ox+3, oy+4); c.lineTo(ox+6, oy+8); c.stroke();
      });
      break;
    }
    case 'sniper': {
      c.fillStyle = col;
      c.beginPath(); c.moveTo(0, -10); c.lineTo(8, -2); c.lineTo(6, 10);
      c.lineTo(-6, 10); c.lineTo(-8, -2); c.closePath(); c.fill();
      c.strokeStyle = '#555'; c.lineWidth = 2;
      c.beginPath(); c.moveTo(8, 0); c.lineTo(20, -8); c.stroke();
      c.strokeStyle = '#fff'; c.lineWidth = 1.5;
      c.beginPath(); c.arc(20, -8, 3, 0, Math.PI*2); c.stroke();
      c.fillStyle = '#f44336';
      c.beginPath(); c.arc(20, -8, 1.2, 0, Math.PI*2); c.fill();
      c.fillStyle = '#ffa000';
      c.beginPath(); c.arc(-2, -4, 2.5, 0, Math.PI*2); c.fill();
      c.fillStyle = '#000';
      c.beginPath(); c.arc(-2, -4, 1, 0, Math.PI*2); c.fill();
      c.fillStyle = '#5d4037';
      c.fillRect(-6, -13, 12, 3);
      c.fillRect(-4, -16, 8, 4);
      break;
    }
    case 'cobra': {
      c.fillStyle = col;
      c.beginPath(); c.moveTo(0, -14);
      c.quadraticCurveTo(18, -6, 12, 8);
      c.lineTo(-12, 8);
      c.quadraticCurveTo(-18, -6, 0, -14);
      c.fill();
      c.fillStyle = '#e53935';
      c.beginPath(); c.moveTo(0, -8); c.lineTo(6, 0); c.lineTo(0, 6); c.lineTo(-6, 0); c.closePath(); c.fill();
      c.fillStyle = '#ff0';
      c.beginPath(); c.arc(-5, -6, 2, 0, Math.PI*2); c.arc(5, -6, 2, 0, Math.PI*2); c.fill();
      c.fillStyle = '#000';
      c.beginPath(); c.arc(-5, -6, 0.8, 0, Math.PI*2); c.arc(5, -6, 0.8, 0, Math.PI*2); c.fill();
      c.fillStyle = '#fff';
      c.beginPath(); c.moveTo(-3, 4); c.lineTo(-2, 10); c.lineTo(-1, 4); c.fill();
      c.beginPath(); c.moveTo(1, 4); c.lineTo(2, 10); c.lineTo(3, 4); c.fill();
      c.fillStyle = 'rgba(118,255,3,0.3)';
      c.beginPath(); c.arc(0, 14, 8, 0, Math.PI*2); c.fill();
      break;
    }
    case 'drake': {
      c.fillStyle = col;
      c.beginPath(); c.moveTo(0, -16); c.lineTo(14, -4); c.lineTo(12, 14);
      c.lineTo(-12, 14); c.lineTo(-14, -4); c.closePath(); c.fill();
      c.fillStyle = 'rgba(74,20,140,0.7)';
      c.beginPath(); c.moveTo(-12, -4); c.lineTo(-22, -14); c.lineTo(-20, -2); c.lineTo(-14, 4); c.closePath(); c.fill();
      c.beginPath(); c.moveTo(12, -4); c.lineTo(22, -14); c.lineTo(20, -2); c.lineTo(14, 4); c.closePath(); c.fill();
      c.strokeStyle = '#7b1fa2'; c.lineWidth = 1;
      c.beginPath(); c.moveTo(-12, -4); c.lineTo(-22, -14); c.moveTo(-14, 0); c.lineTo(-20, -6); c.stroke();
      c.beginPath(); c.moveTo(12, -4); c.lineTo(22, -14); c.moveTo(14, 0); c.lineTo(20, -6); c.stroke();
      c.fillStyle = '#e040fb';
      c.beginPath(); c.arc(-4, -6, 3, 0, Math.PI*2); c.arc(4, -6, 3, 0, Math.PI*2); c.fill();
      c.fillStyle = '#fff';
      c.beginPath(); c.arc(-4, -6, 1.2, 0, Math.PI*2); c.arc(4, -6, 1.2, 0, Math.PI*2); c.fill();
      c.strokeStyle = '#9c27b0'; c.lineWidth = 2;
      c.beginPath(); c.moveTo(-6, -14); c.lineTo(-8, -22); c.moveTo(6, -14); c.lineTo(8, -22); c.stroke();
      c.fillStyle = 'rgba(255,152,0,0.4)';
      c.beginPath(); c.arc(0, 16, 6, 0, Math.PI*2); c.fill();
      break;
    }
    case 'insider': {
      [[-7, 0], [7, 0]].forEach(([ox, oy]) => {
        c.fillStyle = col;
        c.beginPath(); c.ellipse(ox, oy, 7, 6, 0, 0, Math.PI*2); c.fill();
        c.fillStyle = '#d32f2f';
        c.beginPath(); c.moveTo(ox, oy+2); c.lineTo(ox-2, oy+8); c.lineTo(ox+2, oy+8); c.closePath(); c.fill();
        c.fillStyle = '#c0ca33';
        c.beginPath(); c.arc(ox-2, oy-3, 2, 0, Math.PI*2); c.arc(ox+2, oy-3, 2, 0, Math.PI*2); c.fill();
        c.fillStyle = '#000';
        c.beginPath(); c.arc(ox-2, oy-3, 0.8, 0, Math.PI*2); c.arc(ox+2, oy-3, 0.8, 0, Math.PI*2); c.fill();
        c.fillStyle = '#3e2723';
        c.fillRect(ox-4, oy+9, 8, 5);
        c.strokeStyle = '#5d4037'; c.lineWidth = 0.5;
        c.strokeRect(ox-4, oy+9, 8, 5);
      });
      break;
    }
    case 'sentinel': {
      c.fillStyle = col;
      c.fillRect(-14, -12, 28, 26);
      c.strokeStyle = '#546e7a'; c.lineWidth = 2;
      c.strokeRect(-14, -12, 28, 26);
      c.strokeRect(-10, -8, 20, 18);
      c.strokeStyle = 'rgba(100,200,255,0.5)'; c.lineWidth = 2;
      c.beginPath(); c.arc(0, 0, 18, 0, Math.PI*2); c.stroke();
      c.fillStyle = '#90a4ae';
      c.fillRect(-2, -8, 4, 16);
      c.fillRect(-8, -2, 16, 4);
      c.fillStyle = '#64ffda';
      c.beginPath(); c.arc(-5, -4, 2, 0, Math.PI*2); c.arc(5, -4, 2, 0, Math.PI*2); c.fill();
      break;
    }
    case 'splitter': {
      c.fillStyle = col;
      c.beginPath(); c.moveTo(0, -14); c.lineTo(12, 8); c.lineTo(-12, 8); c.closePath(); c.fill();
      c.strokeStyle = '#ffab00'; c.lineWidth = 2; c.setLineDash([3, 3]);
      c.beginPath(); c.moveTo(0, -12); c.lineTo(0, 8); c.stroke();
      c.setLineDash([]);
      c.fillStyle = 'rgba(230,81,0,0.4)';
      c.beginPath(); c.moveTo(-8, 12); c.lineTo(-2, 12); c.lineTo(-5, 18); c.closePath(); c.fill();
      c.beginPath(); c.moveTo(2, 12); c.lineTo(8, 12); c.lineTo(5, 18); c.closePath(); c.fill();
      c.fillStyle = '#ff0';
      c.beginPath(); c.arc(-3, -2, 2, 0, Math.PI*2); c.arc(3, -2, 2, 0, Math.PI*2); c.fill();
      c.fillStyle = '#000';
      c.beginPath(); c.arc(-3, -2, 0.8, 0, Math.PI*2); c.arc(3, -2, 0.8, 0, Math.PI*2); c.fill();
      break;
    }
  }
  c.restore();
}

// ============================================================
//  HOME SCREEN
// ============================================================
function showHomeScreen() {
  showScreen('home-screen');
  gameState = 'home';
  document.getElementById('home-user').textContent = username;
}

// ============================================================
//  DECK SYSTEM (in-game)
// ============================================================
function buildGameDeck() {
  deck = [...playerDeck];
  deckQueue = [...deck].sort(() => Math.random() - 0.5);
  hand = [deckQueue.pop(), deckQueue.pop(), deckQueue.pop(), deckQueue.pop()];
  nextCard = deckQueue.pop();
}

function useGameCard(handIdx) {
  const used = hand[handIdx];
  hand[handIdx] = nextCard;
  if (deckQueue.length === 0) {
    deckQueue = deck.filter(k => k !== hand[0] && k !== hand[1] && k !== hand[2] && k !== hand[3]).sort(() => Math.random() - 0.5);
  }
  nextCard = deckQueue.pop() || deck[Math.floor(Math.random() * deck.length)];
  return used;
}

// ============================================================
//  TOWERS
// ============================================================
function makeTowers() {
  const tw = W*0.1, th = H*0.075, kw = W*0.111, kh = H*0.081;
  const ar = W*0.3;
  return [
    { x:W*0.144, y:H*0.075, w:tw, h:th, hp:1000, maxHp:1000, side:'ai', type:'princess', atkRange:ar, atkDmg:22, atkCd:1.5, atkTimer:0 },
    { x:W*0.756, y:H*0.075, w:tw, h:th, hp:1000, maxHp:1000, side:'ai', type:'princess', atkRange:ar, atkDmg:22, atkCd:1.5, atkTimer:0 },
    { x:W*0.444, y:H*0.025, w:kw, h:kh, hp:2000, maxHp:2000, side:'ai', type:'king', atkRange:ar*1.1, atkDmg:28, atkCd:1.8, atkTimer:0 },
    { x:W*0.144, y:H*0.672, w:tw, h:th, hp:1000, maxHp:1000, side:'player', type:'princess', atkRange:ar, atkDmg:22, atkCd:1.5, atkTimer:0 },
    { x:W*0.756, y:H*0.672, w:tw, h:th, hp:1000, maxHp:1000, side:'player', type:'princess', atkRange:ar, atkDmg:22, atkCd:1.5, atkTimer:0 },
    { x:W*0.444, y:H*0.706, w:kw, h:kh, hp:2000, maxHp:2000, side:'player', type:'king', atkRange:ar*1.1, atkDmg:28, atkCd:1.8, atkTimer:0 },
  ];
}
function tc(t) { return { x: t.x+t.w/2, y: t.y+t.h/2 }; }

// ============================================================
//  PATHFINDING
// ============================================================
function needsBridge(fy, ty) { return (fy > RIVER_BOT && ty < RIVER_TOP) || (fy < RIVER_TOP && ty > RIVER_BOT); }
function nearestBridge(x) {
  const bl = (BRIDGE_L.x1+BRIDGE_L.x2)/2, br = (BRIDGE_R.x1+BRIDGE_R.x2)/2;
  return Math.abs(x-bl) < Math.abs(x-br) ? {x:bl,y:RIVER_MID} : {x:br,y:RIVER_MID};
}
function getWaypoints(ux,uy,tx,ty) {
  if (!needsBridge(uy,ty)) return [{x:tx,y:ty}];
  const b = nearestBridge(ux);
  const enterY = uy > RIVER_MID ? RIVER_BOT+S(4) : RIVER_TOP-S(4);
  const exitY = uy > RIVER_MID ? RIVER_TOP-S(4) : RIVER_BOT+S(4);
  return [{x:b.x,y:enterY},{x:b.x,y:b.y},{x:b.x,y:exitY},{x:tx,y:ty}];
}

// ============================================================
//  UNIT LOGIC
// ============================================================
function S(v) { return v * (W / 360); }

function spawnUnit(type, x, y, side) {
  const def = ALL_CARDS[type];
  const count = def.count || 1;
  for (let i = 0; i < count; i++) {
    const ox = count > 1 ? (i-(count-1)/2)*S(16) : 0;
    const oy = count > 1 ? ((i%2)*S(10)-S(5)) : 0;
    units.push({
      type, side,
      x: Math.max(S(15), Math.min(W-S(15), x+ox)), y: y+oy,
      hp: def.hp, maxHp: def.hp,
      dmg: def.dmg, spd: def.spd * (W/360),
      range: S(def.range), atkSpd: def.atkSpd,
      atkTimer: 0, color: def.color,
      poison: def.poison||0, splash: S(def.splash||0),
      ranged: def.ranged||false, shield: def.shield||0,
      splits: def.splits||false,
      waypoints:[], wpIdx:0, poisonTimer:0,
      animPhase: Math.random()*Math.PI*2,
      lastTargetCalc: 0,
      syncId: isOnline && isHost ? ++unitIdCounter : 0
    });
  }
}

function dist(a,b) { return Math.hypot(a.x-b.x, a.y-b.y); }

function findNearestEnemy(u) {
  let best=null, bd=Infinity;
  for (const o of units) { if (o.side===u.side||o.hp<=0) continue; const d=dist(u,o); if(d<bd){bd=d;best=o;} }
  return best;
}
function findNearestEnemyTower(u) {
  let best=null, bd=Infinity;
  for (const t of towers) { if(t.side===u.side||t.hp<=0) continue; const d=dist(u,tc(t)); if(d<bd){bd=d;best=t;} }
  return best;
}

function updateUnits(dt) {
  const now = performance.now();
  for (let i = units.length-1; i >= 0; i--) {
    const u = units[i];
    if (u.poisonTimer > 0) { u.poisonTimer -= dt; u.hp -= 4*dt; }
    if (u.hp <= 0) {
      spawnDeathFX(u.x,u.y,u.color);
      if (u.splits) {
        for (let s=0;s<2;s++) {
          units.push({...u, hp:u.maxHp*0.4, maxHp:u.maxHp*0.4, dmg:u.dmg*0.5, splits:false, waypoints:[], wpIdx:0, x:u.x+(s?12:-12), y:u.y, animPhase:Math.random()*6});
        }
      }
      units.splice(i,1); continue;
    }
    u.atkTimer = Math.max(0, u.atkTimer-dt);

    if (now - u.lastTargetCalc > 300) {
      u.lastTargetCalc = now;
      const nearU = findNearestEnemy(u);
      const nearT = findNearestEnemyTower(u);
      let tp = null;
      if (nearU && dist(u,nearU) <= u.range+S(10)) { tp = {x:nearU.x,y:nearU.y}; }
      else {
        const ud = nearU ? dist(u,nearU) : Infinity;
        if (nearT) {
          const td = dist(u,tc(nearT));
          if (nearU && ud < td*0.7) tp = {x:nearU.x,y:nearU.y};
          else { const c=tc(nearT); tp={x:c.x,y:c.y}; }
        } else if (nearU) tp = {x:nearU.x,y:nearU.y};
      }
      if (tp) { u.waypoints = getWaypoints(u.x,u.y,tp.x,tp.y); u.wpIdx = 0; }
    }

    let attacked = false;
    if (u.atkTimer <= 0) {
      const nearU = findNearestEnemy(u);
      if (nearU && dist(u,nearU) <= u.range+S(10)) {
        u.atkTimer = u.atkSpd; attacked = true;
        if (u.ranged) projectiles.push({x:u.x,y:u.y,target:nearU,dmg:u.dmg,spd:S(6),color:u.color,poison:u.poison,splash:u.splash});
        else dealDamage(nearU,u.dmg,u);
      }
    }
    if (!attacked && u.atkTimer <= 0) {
      for (const t of towers) {
        if(t.side===u.side||t.hp<=0) continue;
        const c=tc(t);
        if (dist(u,c) <= u.range+S(28)) {
          u.atkTimer=u.atkSpd; attacked=true;
          if(u.ranged) {
            if(shouldDamageTower()) projectiles.push({x:u.x,y:u.y,tx:c.x,ty:c.y,towerRef:t,dmg:u.dmg,spd:S(6),color:u.color});
            else projectiles.push({x:u.x,y:u.y,tx:c.x,ty:c.y,dmg:0,spd:S(6),color:u.color}); // visual only
          } else {
            if(shouldDamageTower()) { t.hp-=u.dmg; dmgNums.push({x:c.x,y:c.y-10,val:u.dmg,life:1,color:'#ffab00'}); }
            else { dmgNums.push({x:c.x,y:c.y-10,val:u.dmg,life:1,color:'#ffab00'}); } // visual only
          }
          break;
        }
      }
    }
    if (attacked) continue;
    if (u.wpIdx < u.waypoints.length) {
      const wp=u.waypoints[u.wpIdx];
      const dx=wp.x-u.x, dy=wp.y-u.y, d=Math.hypot(dx,dy);
      if (d<S(4)) u.wpIdx++;
      else { const step=u.spd*dt*60; u.x+=(dx/d)*step; u.y+=(dy/d)*step; }
    }
  }
}

function dealDamage(target,dmg,attacker) {
  if(target.shield>0){const a=Math.min(target.shield,dmg);target.shield-=a;dmg-=a;}
  target.hp -= dmg;
  dmgNums.push({x:target.x+(Math.random()-0.5)*8,y:target.y-12,val:Math.round(dmg+(attacker.poison||0)),life:1});
  if(attacker.poison) target.poisonTimer=Math.max(target.poisonTimer||0,3);
  if(attacker.splash) units.forEach(u=>{if(u!==target&&u.side!==attacker.side&&dist(target,u)<attacker.splash) u.hp-=dmg*0.35;});
}

function updateTowers(dt) {
  towers.forEach(t=>{
    if(t.hp<=0)return; t.atkTimer=Math.max(0,t.atkTimer-dt);
    if(t.atkTimer>0)return;
    const c=tc(t); let cl=null,cd=Infinity;
    units.forEach(u=>{if(u.side===t.side)return;const d=dist(c,u);if(d<t.atkRange&&d<cd){cd=d;cl=u;}});
    if(cl){t.atkTimer=t.atkCd;projectiles.push({x:c.x,y:c.y,target:cl,dmg:t.atkDmg,spd:S(5),color:t.side==='player'?'#ffd600':'#ff5252'});}
  });
}

// In online mode as guest, don't let local unit attacks damage towers
// (host syncs authoritative tower HP). Only tower arrow projectiles still fire for visual.
function shouldDamageTower() {
  return !isOnline || isHost;
}

function updateProjectiles(dt) {
  for(let i=projectiles.length-1;i>=0;i--){
    const p=projectiles[i];
    let tx,ty;
    if(p.towerRef){tx=p.tx;ty=p.ty;}
    else{tx=(p.target&&p.target.hp>0)?p.target.x:(p.tx||p.x);ty=(p.target&&p.target.hp>0)?p.target.y:(p.ty||p.y);}
    const dx=tx-p.x,dy=ty-p.y,d=Math.hypot(dx,dy);
    if(d<S(8)){
      if(p.towerRef){
        if(shouldDamageTower()){p.towerRef.hp-=p.dmg;}
        dmgNums.push({x:tx,y:ty-10,val:p.dmg,life:1,color:'#ffab00'});
      }
      else if(p.target&&p.target.hp>0) dealDamage(p.target,p.dmg,p);
      projectiles.splice(i,1);
    } else {const s=p.spd*dt*60;p.x+=(dx/d)*s;p.y+=(dy/d)*s;}
  }
}

// ============================================================
//  AI
// ============================================================
function aiInit() {
  const sh=[...CARD_KEYS].sort(()=>Math.random()-0.5);
  aiDeck=sh.slice(0,8); aiQueue=[...aiDeck].sort(()=>Math.random()-0.5);
  aiHand=[aiQueue.pop(),aiQueue.pop(),aiQueue.pop(),aiQueue.pop()]; aiNext=aiQueue.pop();
}
function aiUseCard(idx){
  const used=aiHand[idx]; aiHand[idx]=aiNext;
  if(!aiQueue.length) aiQueue=aiDeck.filter(k=>!aiHand.includes(k)).sort(()=>Math.random()-0.5);
  aiNext=aiQueue.pop()||aiDeck[Math.floor(Math.random()*aiDeck.length)]; return used;
}
function updateAI(dt) {
  if(!vsAI)return;
  aiElixir=Math.min(MAX_ELIXIR,aiElixir+elixirRate*dt);
  aiDeployTimer-=dt; if(aiDeployTimer>0)return;
  const aff=[]; aiHand.forEach((k,i)=>{if(ALL_CARDS[k].cost<=aiElixir)aff.push(i);});
  if(!aff.length)return;
  aiDeployTimer=1.5+Math.random()*2;
  const push=units.filter(u=>u.side==='player'&&u.y<RIVER_TOP+S(40));
  const def=push.length>0;
  const idx=aff[Math.floor(Math.random()*aff.length)];
  const ck=aiUseCard(idx); const cd=ALL_CARDS[ck]; aiElixir-=cd.cost;
  let dx,dy;
  if(def){const th=push[0];dx=th.x+(Math.random()-0.5)*S(40);dy=H*0.125+Math.random()*H*0.156;}
  else{dx=Math.random()<0.5?W*0.167+Math.random()*W*0.222:W*0.611+Math.random()*W*0.222;dy=H*0.156+Math.random()*H*0.188;}
  spawnUnit(ck,Math.max(S(20),Math.min(W-S(20),dx)),dy,'ai');
}

// ============================================================
//  DRAWING
// ============================================================
function drawArena() {
  ctx.fillStyle='#141a14';ctx.fillRect(0,0,W,H);
  ctx.fillStyle='#0f140f';ctx.fillRect(0,0,W,RIVER_TOP);
  ctx.fillStyle='#161c16';ctx.fillRect(0,RIVER_BOT,W,H-RIVER_BOT);

  ctx.strokeStyle='rgba(197,164,78,0.03)';ctx.lineWidth=1;
  const gs=S(36);
  for(let x=0;x<W;x+=gs){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,H);ctx.stroke();}
  for(let y=0;y<H;y+=gs){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(W,y);ctx.stroke();}

  const t=performance.now()/1000;
  ctx.fillStyle='#0a1e2a';ctx.fillRect(0,RIVER_TOP,W,RIVER_BOT-RIVER_TOP);
  ctx.fillStyle='rgba(40,80,100,0.2)';
  for(let x=0;x<W;x+=S(16)){const wy=Math.sin(t*1.8+x*0.1)*S(2);ctx.fillRect(x,RIVER_MID-S(1)+wy,S(10),S(2));}

  ctx.fillStyle='#3a3a30';
  ctx.fillRect(BRIDGE_L.x1,RIVER_TOP-S(3),BRIDGE_L.x2-BRIDGE_L.x1,RIVER_BOT-RIVER_TOP+S(6));
  ctx.fillRect(BRIDGE_R.x1,RIVER_TOP-S(3),BRIDGE_R.x2-BRIDGE_R.x1,RIVER_BOT-RIVER_TOP+S(6));
  ctx.strokeStyle='#2a2a22';ctx.lineWidth=1;
  for(let y=RIVER_TOP;y<RIVER_BOT;y+=S(8)){
    ctx.beginPath();ctx.moveTo(BRIDGE_L.x1,y);ctx.lineTo(BRIDGE_L.x2,y);ctx.stroke();
    ctx.beginPath();ctx.moveTo(BRIDGE_R.x1,y);ctx.lineTo(BRIDGE_R.x2,y);ctx.stroke();
  }
  ctx.fillStyle='#4a4a3e';
  ctx.fillRect(BRIDGE_L.x1,RIVER_TOP-S(3),BRIDGE_L.x2-BRIDGE_L.x1,S(2));
  ctx.fillRect(BRIDGE_L.x1,RIVER_BOT+S(1),BRIDGE_L.x2-BRIDGE_L.x1,S(2));
  ctx.fillRect(BRIDGE_R.x1,RIVER_TOP-S(3),BRIDGE_R.x2-BRIDGE_R.x1,S(2));
  ctx.fillRect(BRIDGE_R.x1,RIVER_BOT+S(1),BRIDGE_R.x2-BRIDGE_R.x1,S(2));

  ctx.strokeStyle='rgba(197,164,78,0.08)';ctx.setLineDash([S(6),S(10)]);
  ctx.beginPath();ctx.moveTo(0,H/2);ctx.lineTo(W,H/2);ctx.stroke();ctx.setLineDash([]);

  ctx.fillStyle='rgba(197,164,78,0.02)';
  ctx.beginPath();ctx.moveTo(W/2,S(2));ctx.lineTo(W/2-S(4),S(40));ctx.lineTo(W/2+S(4),S(40));ctx.closePath();ctx.fill();
  ctx.beginPath();ctx.arc(W/2,H-S(8),S(20),Math.PI,0);ctx.fill();
}

function drawTowers() {
  towers.forEach(t=>{
    if(t.hp<=0){ctx.fillStyle='rgba(100,100,100,0.3)';ctx.fillRect(t.x+S(5),t.y+S(10),t.w-S(10),t.h-S(10));return;}
    const cx=t.x+t.w/2,cy=t.y+t.h/2;
    ctx.fillStyle='rgba(0,0,0,0.25)';ctx.beginPath();ctx.ellipse(cx,t.y+t.h+S(3),t.w/2,S(4),0,0,Math.PI*2);ctx.fill();
    const g=ctx.createLinearGradient(t.x,t.y,t.x,t.y+t.h);
    if(t.side==='player'){g.addColorStop(0,'#c5a44e');g.addColorStop(1,'#8a7030');}
    else{g.addColorStop(0,'#8b3a3a');g.addColorStop(1,'#5a1a1a');}
    ctx.fillStyle=g;
    ctx.fillRect(t.x+2,t.y+t.h*0.2,t.w-4,t.h*0.8);
    ctx.beginPath();ctx.moveTo(cx,t.y);ctx.lineTo(t.x+t.w-2,t.y+t.h*0.2);ctx.lineTo(t.x+2,t.y+t.h*0.2);ctx.closePath();ctx.fill();
    ctx.strokeStyle=t.side==='player'?'rgba(100,80,30,0.3)':'rgba(60,20,20,0.3)';ctx.lineWidth=1;
    for(let ly=t.y+t.h*0.3;ly<t.y+t.h;ly+=S(8)){ctx.beginPath();ctx.moveTo(t.x+S(3),ly);ctx.lineTo(t.x+t.w-S(3),ly);ctx.stroke();}
    if(t.type==='king'){
      ctx.fillStyle=t.side==='player'?'#e8d48a':'#c06060';
      const crY=t.y-S(4);
      for(let a=0;a<5;a++){const ang=a*Math.PI*2/5-Math.PI/2;
        ctx.beginPath();ctx.arc(cx+Math.cos(ang)*S(6),crY+S(4)+Math.sin(ang)*S(6),S(2),0,Math.PI*2);ctx.fill();}
      ctx.beginPath();ctx.arc(cx,crY+S(4),S(3),0,Math.PI*2);ctx.fill();
    }
    const bw=t.w+S(6),bh=S(5),bx=t.x-S(3),by=t.y-S(12);
    ctx.fillStyle='#1a1a1a';ctx.fillRect(bx,by,bw,bh);
    const r=t.hp/t.maxHp;ctx.fillStyle=r>0.5?'#4caf50':r>0.25?'#ff9800':'#f44336';
    ctx.fillRect(bx,by,bw*r,bh);
    ctx.fillStyle='white';ctx.font=`bold ${S(8)}px sans-serif`;ctx.textAlign='center';
    ctx.fillText(Math.ceil(t.hp),cx,by-S(2));
  });
}

function drawUnit(u) {
  const t=performance.now()/1000, bob=Math.sin(t*4+u.animPhase)*S(1.5);
  ctx.save();ctx.translate(u.x,u.y+bob);
  const sc=W/360; ctx.scale(sc,sc);
  const s=u.side==='player'?1:-1;
  const fn={
    lobbyist(){ctx.fillStyle=u.color;ctx.beginPath();ctx.ellipse(0,0,7,5,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#ff0';ctx.beginPath();ctx.arc(-2,-3*s,1.5,0,Math.PI*2);ctx.arc(2,-3*s,1.5,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#000';ctx.beginPath();ctx.arc(-2,-3*s,0.7,0,Math.PI*2);ctx.arc(2,-3*s,0.7,0,Math.PI*2);ctx.fill();},
    viper(){ctx.strokeStyle=u.color;ctx.lineWidth=4;ctx.lineCap='round';ctx.beginPath();ctx.moveTo(0,0);
      for(let i=1;i<=3;i++)ctx.lineTo(Math.sin(t*3+i)*5,i*4*s);ctx.stroke();
      ctx.fillStyle=u.color;ctx.beginPath();ctx.arc(0,0,4,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#f00';ctx.beginPath();ctx.arc(-1.5,-2*s,1,0,Math.PI*2);ctx.arc(1.5,-2*s,1,0,Math.PI*2);ctx.fill();},
    behemoth(){ctx.fillStyle=u.color;ctx.beginPath();ctx.moveTo(0,-13);ctx.lineTo(13,-3);ctx.lineTo(11,11);
      ctx.lineTo(-11,11);ctx.lineTo(-13,-3);ctx.closePath();ctx.fill();
      ctx.fillStyle='#ffab00';ctx.beginPath();ctx.arc(-4,-3,2.5,0,Math.PI*2);ctx.arc(4,-3,2.5,0,Math.PI*2);ctx.fill();
      ctx.strokeStyle='#5d4037';ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(-7,-9);ctx.lineTo(-11,-17);ctx.moveTo(7,-9);ctx.lineTo(11,-17);ctx.stroke();},
    assassin(){ctx.fillStyle=u.color;ctx.beginPath();ctx.moveTo(0,-9);ctx.lineTo(7,0);ctx.lineTo(0,9);ctx.lineTo(-7,0);ctx.closePath();ctx.fill();
      ctx.fillStyle='#e040fb';ctx.beginPath();ctx.arc(-2,-1,1.5,0,Math.PI*2);ctx.arc(2,-1,1.5,0,Math.PI*2);ctx.fill();
      ctx.strokeStyle='#ce93d8';ctx.lineWidth=1.5;ctx.beginPath();ctx.moveTo(-7,0);ctx.lineTo(-13,-3);ctx.moveTo(7,0);ctx.lineTo(13,-3);ctx.stroke();},
    gator(){ctx.fillStyle=u.color;ctx.beginPath();ctx.ellipse(0,0,10,7,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#004d40';ctx.fillRect(-8,-3*s,16,4);
      ctx.fillStyle='#ffeb3b';ctx.beginPath();ctx.arc(-4,-4*s,1.5,0,Math.PI*2);ctx.arc(4,-4*s,1.5,0,Math.PI*2);ctx.fill();},
    filibuster(){ctx.fillStyle=u.color;ctx.beginPath();ctx.arc(0,0,5,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#000';ctx.beginPath();ctx.arc(-1.5,-1.5*s,1,0,Math.PI*2);ctx.arc(1.5,-1.5*s,1,0,Math.PI*2);ctx.fill();
      ctx.strokeStyle=u.color;ctx.lineWidth=1;ctx.beginPath();ctx.moveTo(-3,4*s);ctx.lineTo(-5,8*s);ctx.moveTo(3,4*s);ctx.lineTo(5,8*s);ctx.stroke();},
    sniper(){ctx.fillStyle=u.color;ctx.beginPath();ctx.moveTo(0,-8);ctx.lineTo(6,0);ctx.lineTo(4,8);ctx.lineTo(-4,8);ctx.lineTo(-6,0);ctx.closePath();ctx.fill();
      ctx.strokeStyle='#fff';ctx.lineWidth=1;ctx.beginPath();ctx.arc(0,-4*s,3,0,Math.PI*2);ctx.stroke();
      ctx.fillStyle='#f00';ctx.beginPath();ctx.arc(0,-4*s,1,0,Math.PI*2);ctx.fill();},
    cobra(){ctx.fillStyle=u.color;ctx.beginPath();ctx.moveTo(0,-10);ctx.quadraticCurveTo(12,-4,8,6);ctx.lineTo(-8,6);ctx.quadraticCurveTo(-12,-4,0,-10);ctx.fill();
      ctx.fillStyle='#ff0';ctx.beginPath();ctx.arc(-3,-4,1.5,0,Math.PI*2);ctx.arc(3,-4,1.5,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#fff';ctx.beginPath();ctx.moveTo(-2,2);ctx.lineTo(-1,6);ctx.lineTo(0,2);ctx.moveTo(0,2);ctx.lineTo(1,6);ctx.lineTo(2,2);ctx.fill();},
    drake(){ctx.fillStyle=u.color;ctx.beginPath();ctx.moveTo(0,-16);ctx.lineTo(14,-4);ctx.lineTo(12,14);ctx.lineTo(-12,14);ctx.lineTo(-14,-4);ctx.closePath();ctx.fill();
      ctx.fillStyle='rgba(74,20,140,0.6)';ctx.beginPath();ctx.moveTo(-10,-4);ctx.lineTo(-22,-10);ctx.lineTo(-14,4);ctx.closePath();ctx.fill();
      ctx.beginPath();ctx.moveTo(10,-4);ctx.lineTo(22,-10);ctx.lineTo(14,4);ctx.closePath();ctx.fill();
      ctx.fillStyle='#e040fb';ctx.beginPath();ctx.arc(-4,-6,2.5,0,Math.PI*2);ctx.arc(4,-6,2.5,0,Math.PI*2);ctx.fill();},
    insider(){ctx.fillStyle=u.color;ctx.beginPath();ctx.ellipse(0,0,7,6,0,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#c0ca33';ctx.beginPath();ctx.arc(-2,-3*s,1.5,0,Math.PI*2);ctx.arc(2,-3*s,1.5,0,Math.PI*2);ctx.fill();
      ctx.fillStyle='#d32f2f';ctx.beginPath();ctx.moveTo(0,2);ctx.lineTo(-2,7*s);ctx.lineTo(2,7*s);ctx.closePath();ctx.fill();},
    sentinel(){ctx.fillStyle=u.color;ctx.fillRect(-11,-11,22,22);ctx.strokeStyle='#546e7a';ctx.lineWidth=2;ctx.strokeRect(-11,-11,22,22);
      if(u.shield>0){ctx.strokeStyle='rgba(100,200,255,0.6)';ctx.lineWidth=2;ctx.beginPath();ctx.arc(0,0,15,0,Math.PI*2);ctx.stroke();}
      ctx.fillStyle='#90a4ae';ctx.beginPath();ctx.arc(-4,-3,2,0,Math.PI*2);ctx.arc(4,-3,2,0,Math.PI*2);ctx.fill();},
    splitter(){ctx.fillStyle=u.color;ctx.beginPath();ctx.moveTo(0,-8);ctx.lineTo(9,4);ctx.lineTo(-9,4);ctx.closePath();ctx.fill();
      ctx.strokeStyle='#ffab00';ctx.lineWidth=1;ctx.setLineDash([2,2]);ctx.beginPath();ctx.moveTo(0,-6);ctx.lineTo(0,4);ctx.stroke();ctx.setLineDash([]);
      ctx.fillStyle='#ff0';ctx.beginPath();ctx.arc(-3,-2,1.5,0,Math.PI*2);ctx.arc(3,-2,1.5,0,Math.PI*2);ctx.fill();}
  };
  (fn[u.type]||fn.lobbyist)();
  ctx.restore();
  ctx.strokeStyle=u.side==='player'?'rgba(255,215,0,0.35)':'rgba(255,60,60,0.3)';ctx.lineWidth=1;
  ctx.beginPath();ctx.ellipse(u.x,u.y+S(9)+bob,S(9),S(3.5),0,0,Math.PI*2);ctx.stroke();
  if(u.hp<u.maxHp){const bw=S(18),bh=S(3);ctx.fillStyle='#111';ctx.fillRect(u.x-bw/2,u.y-S(16),bw,bh);
    ctx.fillStyle=u.side==='player'?'#4caf50':'#f44336';ctx.fillRect(u.x-bw/2,u.y-S(16),bw*Math.max(0,u.hp/u.maxHp),bh);}
  if(u.shield>0&&ALL_CARDS[u.type].shield){ctx.fillStyle='rgba(100,200,255,0.7)';
    ctx.fillRect(u.x-S(9),u.y-S(19),S(18)*(u.shield/ALL_CARDS[u.type].shield),S(2));}
}

function drawProjectiles(){projectiles.forEach(p=>{ctx.fillStyle=p.color||'#ffeb3b';ctx.beginPath();ctx.arc(p.x,p.y,S(3),0,Math.PI*2);ctx.fill();
  ctx.fillStyle=(p.color||'#ffeb3b')+'44';ctx.beginPath();ctx.arc(p.x,p.y,S(6),0,Math.PI*2);ctx.fill();});}

function spawnDeathFX(x,y,color){for(let i=0;i<6;i++)particles.push({x,y,vx:(Math.random()-0.5)*S(4),vy:(Math.random()-0.5)*S(4)-S(2),color,life:1});}

function drawParticles(){for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.life-=0.025;if(p.life<=0){particles.splice(i,1);continue;}
  p.x+=p.vx;p.y+=p.vy;p.vy+=S(0.08);ctx.globalAlpha=p.life;ctx.fillStyle=p.color;const ps=S(2);ctx.fillRect(p.x-ps,p.y-ps,ps*2,ps*2);}ctx.globalAlpha=1;}

function drawDmgNums(){for(let i=dmgNums.length-1;i>=0;i--){const d=dmgNums[i];d.life-=0.03;d.y-=S(0.7);
  if(d.life<=0){dmgNums.splice(i,1);continue;}ctx.globalAlpha=d.life;ctx.fillStyle=d.color||'#ff5252';
  ctx.font=`bold ${S(10)}px sans-serif`;ctx.textAlign='center';ctx.fillText('-'+d.val,d.x,d.y);}ctx.globalAlpha=1;}

function drawDeployZone(){if(!selectedCard)return;ctx.fillStyle='rgba(197,164,78,0.05)';
  ctx.fillRect(0,DEPLOY_MIN_Y,W,DEPLOY_MAX_Y-DEPLOY_MIN_Y);ctx.strokeStyle='rgba(197,164,78,0.2)';
  ctx.setLineDash([S(5),S(5)]);ctx.beginPath();ctx.moveTo(0,DEPLOY_MIN_Y);ctx.lineTo(W,DEPLOY_MIN_Y);ctx.stroke();ctx.setLineDash([]);}

// ============================================================
//  IN-GAME HUD
// ============================================================
function buildInGameCards() {
  const container = document.getElementById('cards');
  container.innerHTML = '';
  for (let i = 0; i < 4; i++) {
    const card = document.createElement('div');
    card.className = 'card'; card.dataset.handIdx = i;
    const def = ALL_CARDS[hand[i]];
    card.innerHTML = `<div class="card-cost">${def.cost}</div><canvas width="40" height="40"></canvas><div class="card-name">${def.name.split(' ')[0]}</div><div class="card-stats">${def.tag}</div>`;
    container.appendChild(card);
    drawDetailedIcon(card.querySelector('canvas'), hand[i], 40);
    card.addEventListener('click', () => {
      const idx = parseInt(card.dataset.handIdx);
      const key = hand[idx];
      if (elixir < ALL_CARDS[key].cost) return;
      document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
      if (selectedCard && selectedCard.handIdx === idx) { selectedCard = null; }
      else { selectedCard = { handIdx: idx, type: key, cost: ALL_CARDS[key].cost }; card.classList.add('selected'); }
    });
  }
  updateNextCardUI();
}

function refreshInGameCards() {
  const cards = document.querySelectorAll('#cards .card');
  cards.forEach((card, i) => {
    const key = hand[i]; const def = ALL_CARDS[key];
    card.dataset.handIdx = i;
    card.querySelector('.card-cost').textContent = def.cost;
    card.querySelector('.card-name').textContent = def.name.split(' ')[0];
    card.querySelector('.card-stats').textContent = def.tag;
    drawDetailedIcon(card.querySelector('canvas'), key, 40);
    card.classList.toggle('disabled', elixir < def.cost);
  });
  updateNextCardUI();
}

function updateNextCardUI() {
  const el = document.getElementById('next-card');
  el.innerHTML = '';
  if (!nextCard) return;
  const cvs = document.createElement('canvas');
  cvs.width = 30; cvs.height = 30;
  drawDetailedIcon(cvs, nextCard, 30);
  el.appendChild(cvs);
  const costEl = document.createElement('div');
  costEl.style.cssText = 'font-size:8px;color:#888;margin-top:1px;';
  costEl.textContent = ALL_CARDS[nextCard].cost;
  el.appendChild(costEl);
}

function updateCardDisabled() {
  document.querySelectorAll('#cards .card').forEach((card, i) => {
    card.classList.toggle('disabled', elixir < ALL_CARDS[hand[i]].cost);
  });
}

// ============================================================
//  WIN / LOSS
// ============================================================
function checkGameEnd() {
  // In online mode, only HOST determines game result
  if (isOnline && !isHost) return;

  const pk=towers.find(t=>t.side==='player'&&t.type==='king');
  const ak=towers.find(t=>t.side==='ai'&&t.type==='king');

  if(pk.hp<=0) {
    if (isOnline) { sendGameResult(false); endGame(false); }
    else endGame(false);
    return;
  }
  if(ak.hp<=0) {
    if (isOnline) { sendGameResult(true); endGame(true); }
    else endGame(true);
    return;
  }

  const mx=GAME_DURATION+(overtime?OT_DURATION:0);
  if(gameTime>=mx){
    const php=towers.filter(t=>t.side==='player').reduce((s,t)=>s+Math.max(0,t.hp),0);
    const ahp=towers.filter(t=>t.side==='ai').reduce((s,t)=>s+Math.max(0,t.hp),0);
    if(php>ahp) {
      if (isOnline) { sendGameResult(true); endGame(true); }
      else endGame(true);
    } else if(ahp>php) {
      if (isOnline) { sendGameResult(false); endGame(false); }
      else endGame(false);
    } else {
      // Tied — go to overtime first, then sudden death
      if(!overtime){overtime=true;elixirRate=2;return;}
      // Still tied after OT — it's a draw
      if (isOnline) { sendGameResult(false); endGame(false, 'Draw after overtime.'); }
      else endGame(false, 'Draw after overtime.');
    }
  }
}

function endGame(won, reason) {
  if (gameOver) return; // prevent double-end
  gameOver=true;gameState='gameover';
  document.getElementById('overlay').classList.add('show');
  document.getElementById('result-text').textContent=won?'VICTORY':'DEFEAT';
  document.getElementById('result-text').style.color=won?'#ffd600':'#f44336';
  const defaultMsg = won ? 'The swamp has been drained.' : 'The deep state wins... for now.';
  document.getElementById('result-sub').textContent = reason || defaultMsg;
  if (isOnline) cleanupMatch();
}

function updateTimerUI(){
  const mx=overtime?GAME_DURATION+OT_DURATION:GAME_DURATION;
  const rem=Math.max(0,Math.ceil(mx-gameTime));
  const m=Math.floor(rem/60),s=rem%60;
  const el=document.getElementById('timer');
  el.textContent=(overtime?'OT ':'')+m+':'+String(s).padStart(2,'0');
  el.style.color=overtime?'#f44336':'#777';
}
function updateElixirUI(){
  document.getElementById('elixir-fill').style.width=(elixir/MAX_ELIXIR*100)+'%';
  document.getElementById('elixir-text').textContent=Math.floor(elixir)+' / '+MAX_ELIXIR;
}

// ============================================================
//  CANVAS INPUT
// ============================================================
let inputBound = false;
function setupInput() {
  if (inputBound) return;
  inputBound = true;
  const handler = (e) => {
    // Only handle input during active gameplay
    if (!selectedCard || gameOver || gameState !== 'playing') return;
    // Don't intercept if a screen overlay is visible
    if (document.querySelector('.screen.show')) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const sx = W/rect.width, sy = H/rect.height;
    let cx,cy;
    if(e.touches){cx=(e.touches[0].clientX-rect.left)*sx;cy=(e.touches[0].clientY-rect.top)*sy;}
    else{cx=(e.clientX-rect.left)*sx;cy=(e.clientY-rect.top)*sy;}
    if(cy<DEPLOY_MIN_Y||cy>DEPLOY_MAX_Y) return;
    const def=ALL_CARDS[selectedCard.type]; if(elixir<def.cost) return;
    elixir -= def.cost;
    if (isOnline && !isHost) {
      // Guest: send deploy to host — unit appears via next state sync
      sendDeploy(selectedCard.type, cx, cy);
    } else {
      // Host or VS AI: spawn locally (host's sim is authoritative)
      spawnUnit(selectedCard.type, cx, cy, 'player');
    }
    useGameCard(selectedCard.handIdx);
    document.querySelectorAll('.card').forEach(c=>c.classList.remove('selected'));
    selectedCard = null;
    refreshInGameCards();
  };
  canvas.addEventListener('click', handler);
  canvas.addEventListener('touchstart', handler, {passive:false});
}

// ============================================================
//  GAME INIT & LOOP
// ============================================================
function sizeCanvas() {
  const vw = window.innerWidth, vh = window.innerHeight;
  const aspect = 9/16;
  let cw, ch;
  if (vw/vh < aspect) { cw = vw; ch = vw / aspect; }
  else { ch = vh; cw = ch * aspect; }
  const dpr = Math.min(window.devicePixelRatio || 1, 3);
  W = Math.round(cw * dpr);
  H = Math.round(ch * dpr);
  canvas.width = W; canvas.height = H;
  canvas.style.width = cw + 'px';
  canvas.style.height = ch + 'px';
  canvas.style.position = 'absolute';
  canvas.style.left = ((vw - cw)/2) + 'px';
  canvas.style.top = ((vh - ch)/2) + 'px';
}

function initGame() {
  gameState = 'playing';
  document.querySelectorAll('.screen').forEach(s=>s.classList.remove('show'));
  canvas = document.getElementById('arena');
  ctx = canvas.getContext('2d');
  sizeCanvas();
  recalcLayout();

  elixir=5;aiElixir=5;elixirRate=1;
  units=[];projectiles=[];particles=[];dmgNums=[];
  towers=makeTowers();selectedCard=null;
  gameTime=0;overtime=false;gameOver=false;lastFrameTime=0;aiDeployTimer=1;
  lastStateSync=0;unitIdCounter=0;processedDeploys=new Set();

  buildGameDeck();
  if(vsAI) aiInit();

  ['hud','timer','next-card','next-card-label','player-name-hud','ai-name-hud'].forEach(id=>{
    document.getElementById(id).style.display='';
  });
  document.getElementById('overlay').classList.remove('show');
  document.getElementById('player-name-hud').textContent = username;
  document.getElementById('ai-name-hud').textContent = vsAI ? 'CPU' : (opponentName || 'Opponent');

  buildInGameCards();
  setupInput();
  lastFrameTime=0;
  requestAnimationFrame(gameLoop);

  // Host: also run sim via setInterval so it doesn't pause in background tabs
  if (isOnline && isHost) {
    if (window._hostSimInterval) clearInterval(window._hostSimInterval);
    let lastSim = performance.now();
    window._hostSimInterval = setInterval(() => {
      if (gameOver || gameState !== 'playing') { clearInterval(window._hostSimInterval); return; }
      const now = performance.now();
      const dt = Math.min((now - lastSim) / 1000, 0.1);
      lastSim = now;
      if (document.hidden) {
        // Tab is backgrounded — run sim without rendering
        gameTime += dt; elixir = Math.min(MAX_ELIXIR, elixir + elixirRate * dt);
        if (gameTime >= GAME_DURATION && !overtime) { overtime = true; elixirRate = 2; }
        updateUnits(dt); updateTowers(dt); updateProjectiles(dt);
        syncGameState();
        checkGameEnd();
      }
    }, 200);
  }
}

function gameLoop(ts) {
  if(gameState!=='playing'&&gameState!=='gameover') return;
  if(!lastFrameTime) lastFrameTime=ts;
  const dt=Math.min((ts-lastFrameTime)/1000,0.05);lastFrameTime=ts;
  if(!gameOver){
    if (isOnline && !isHost) {
      // GUEST: Don't run unit/tower sim — just interpolate positions from host snapshots
      // Only update local elixir for card UI, projectile visuals, and particles
      elixir=Math.min(MAX_ELIXIR,elixir+elixirRate*dt);
      if(gameTime>=GAME_DURATION&&!overtime){overtime=true;elixirRate=2;}
      interpolateGuestUnits(dt);
      updateProjectiles(dt); // visual only, tower refs removed for guest
      updateTimerUI();updateElixirUI();updateCardDisabled();
    } else {
      // HOST or VS AI: Full simulation
      gameTime+=dt;elixir=Math.min(MAX_ELIXIR,elixir+elixirRate*dt);
      if(gameTime>=GAME_DURATION&&!overtime){overtime=true;elixirRate=2;}
      updateUnits(dt);updateTowers(dt);updateProjectiles(dt);
      if(vsAI) updateAI(dt);
      if(isOnline && isHost) syncGameState();
      checkGameEnd();updateTimerUI();updateElixirUI();updateCardDisabled();
    }
  }
  drawArena();drawDeployZone();drawTowers();
  units.forEach(drawUnit);drawProjectiles();drawParticles();drawDmgNums();
  requestAnimationFrame(gameLoop);
}

// Guest dead reckoning: predict unit movement between syncs
function interpolateGuestUnits(dt) {
  for (const u of units) {
    if (u.targetX === undefined) continue;
    const dx = u.targetX - u.x;
    const dy = u.targetY - u.y;
    const d = Math.hypot(dx, dy);

    if (d < S(2)) {
      // Close enough — snap and use predicted velocity
      u.x = u.targetX;
      u.y = u.targetY;
      // Continue moving in last known direction
      if (u.velX !== undefined) {
        u.x += u.velX * dt;
        u.y += u.velY * dt;
      }
    } else if (d > S(80)) {
      // Too far — teleport (unit probably just spawned or big correction)
      u.x = u.targetX;
      u.y = u.targetY;
    } else {
      // Move toward target at unit's actual speed (not lerp)
      const moveSpeed = u.spd * dt * 60;
      const step = Math.min(moveSpeed * 2, d); // slightly faster than normal to catch up
      u.x += (dx / d) * step;
      u.y += (dy / d) * step;
    }
  }
}

function playAgain(){
  document.getElementById('overlay').classList.remove('show');
  if (isOnline) {
    isOnline = false;
    startOnline();
  } else {
    initGame();
  }
}

function returnHome(){
  gameState='home';
  document.getElementById('overlay').classList.remove('show');
  if (isOnline) cleanupMatch();
  isOnline = false;
  showHomeScreen();
}

// ============================================================
//  HOME SCREEN BUTTONS
// ============================================================
document.getElementById('btn-ai').addEventListener('click', ()=>{ vsAI=true;isOnline=false;initGame(); });
document.getElementById('btn-online').addEventListener('click', startOnline);
document.getElementById('btn-deck').addEventListener('click', ()=>showDeckBuilder(true));

// ============================================================
//  BOOT
// ============================================================
window.addEventListener('load', () => {
  canvas = document.getElementById('arena');
  sizeCanvas();
  recalcLayout();

  loadProfile();

  if (username && playerDeck.length === DECK_SIZE) {
    showHomeScreen();
  } else if (username) {
    showDeckBuilder(false);
  } else {
    showScreen('welcome-screen');
    initWelcome();
  }
});

document.addEventListener('DOMContentLoaded', initWelcome);
window.addEventListener('resize', () => {
  canvas = document.getElementById('arena');
  sizeCanvas(); recalcLayout();
});
</script>
</body>
</html>
